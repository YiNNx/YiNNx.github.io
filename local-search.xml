<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Note for Python</title>
    <link href="/2022/02/10/PythonNote/"/>
    <url>/2022/02/10/PythonNote/</url>
    
    <content type="html"><![CDATA[<h2 id="一些初学Python的笔记"><a href="#一些初学Python的笔记" class="headerlink" title="一些初学Python的笔记"></a>一些初学Python的笔记</h2><h4 id="动态语言-amp-静态语言："><a href="#动态语言-amp-静态语言：" class="headerlink" title="动态语言 &amp; 静态语言："></a>动态语言 &amp; 静态语言：</h4><ul><li><p><strong>动态语言：</strong>变量本身类型不固定。使用变量无需声明，但使用前必须赋值，赋值后变量才被创建。</p><p><strong>e.g. Python、Ruby、JavaScript</strong></p></li><li><p><strong>静态语言：</strong>变量类型固定。在定义变量时必须指定变量类型，赋值时变量与对象的类型必须相匹配or进行转化。</p><p><strong>e.g. Java、C、C++</strong></p></li></ul><h4 id="引用赋值："><a href="#引用赋值：" class="headerlink" title="引用赋值："></a>引用赋值：</h4><p>像Python、JS这类动态语言，基本上都是使用引用赋值。在引用赋值中，变量名和真实值分开保存。变量名保存的是真实值的一个指针，对变量赋值时，也是将这个指针赋给新变量，原来的“引用”则断开了。</p><h4 id="Python中的不可变类型-amp-可变类型："><a href="#Python中的不可变类型-amp-可变类型：" class="headerlink" title="Python中的不可变类型 &amp; 可变类型："></a>Python中的不可变类型 &amp; 可变类型：</h4><ul><li><p><strong>不可变类型： Number、String、Tuple</strong></p><p>当变量为不可变类型时，无法在内存中直接修改这个变量（如：100、’hello‘）。如果尝试对不可变类型进行修改，就会断开原始的引用，重新指向新的对象。</p></li><li><p><strong>可变类型：List、Dictionary、Set</strong></p><p>可以在内存中进行修改，修改可变类型的值不会断开原始引用。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iFleaBooks</title>
    <link href="/2022/02/06/iFleaBooks/"/>
    <url>/2022/02/06/iFleaBooks/</url>
    
    <content type="html"><![CDATA[<p>一个Linux环境下的二手书交易系统</p><p>作为练手项目，实现了较完整的交易系统前后台功能，包括用户注册、登录、浏览商品、发布商品、修改信息，管理员进行后台数据管理，本地数据载入与更新等，并基于Linux命令行进行交互。</p><p>GitHub链接：<a href="https://github.com/yinn-x/iFleaBooks">https://github.com/yinn-x/iFleaBooks</a></p><hr><ul><li><p>开发环境：</p><ul><li><p>Ubuntu 21.10</p></li><li><p>VS Code</p></li></ul></li><li><p>实现功能：</p><ul><li>User：<ul><li>注册 &amp; 登录 &amp; 注销；</li><li>浏览书库 &#x2F; 搜索书籍 &amp; 查看书的详细信息；</li><li>购买二手书 &amp; 查看已购订单；</li><li>发布二手书 &amp; 修改详细信息；</li><li>下架自己的发布 &amp; 查看卖出订单；</li><li>个人信息管理 &amp; 钱包充值。</li></ul></li><li>Admin：<ul><li>查看 &#x2F; 检索所有书籍 &amp; 下架书籍；</li><li>查看和管理所有订单；</li><li>查看和管理所有用户信息。</li></ul></li></ul></li><li><p>优化方向：</p><p>后续将加入MySQL作为数据库。</p></li><li><p>效果</p><ul><li>登录界面：</li></ul><img src="/img/iFleaBooks/1.png" style="zoom:30%;" /><ul><li>买书界面：</li></ul><img src="/img/iFleaBooks/2.png" style="zoom:50%;" /><ul><li>钱包充值：</li></ul><img src="/img/iFleaBooks/3.png" style="zoom:50%;" /></li></ul>]]></content>
    
    
    <categories>
      
      <category>Projects</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note of C++ Primer</title>
    <link href="/2022/02/02/Note%20of%20C++%20Primer/"/>
    <url>/2022/02/02/Note%20of%20C++%20Primer/</url>
    
    <content type="html"><![CDATA[<h2 id="从-C-到-C"><a href="#从-C-到-C" class="headerlink" title="从 C 到 C++"></a>从 C 到 C++</h2><p>一些 C++ 的新特性：</p><ul><li><p><strong>多态：</strong></p><ul><li><p>静态多态：（1）重载（函数重载 &amp; 运算符重载） </p><p>​                   （2）泛型（函数模板 &amp; 类模板）</p><ul><li>动态多态：虚函数</li></ul></li></ul></li><li><p><strong>类：</strong></p><ul><li><p>继承（基类 &amp; 子类）</p></li><li><p>封装 （类访问修饰符 &amp; 友元）</p></li><li><p>其他细节：（1）类的默认函数</p><p>​                   （2）运算符重载</p><p>​                   （3）this 指针</p></li></ul></li><li><p><strong>其他：</strong></p><ul><li><p>引用变量</p></li><li><p>范围 for 语句</p></li><li><p>迭代器</p></li><li><p>内联函数</p></li><li><p>new &amp; delete</p></li><li><p>流式文件读写</p></li><li><p>函数的默认参数</p></li></ul></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h4 id="1-泛型编程"><a href="#1-泛型编程" class="headerlink" title="1. 泛型编程"></a>1. 泛型编程</h4><p>泛型编程属于静态多态，在 C++ 中主要通过模板函数和模板类实现。</p><p>函数模板的性质：</p><ol><li>函数模板不是真正的函数，只是编译时生成具体函数的一个”模子”。</li><li>函数模板不是编译一份满足多重需要，而是为每一种替换它的函数编译生成一份新函数。</li></ol><p>函数模板的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span>&#123;<br>T t = a;<br>a = b, b = t;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>template用于声明开始泛型编程，typyname用于声明泛指类型。</p></li><li><p>自动类型推导调用:</p><p><code> Swap(a, b);</code> </p><p>该调用属于隐式实例化。</p></li><li><p>具体类型显式调用：</p><p><code>Swap&lt;int&gt;(a, b);</code></p><p>该调用属于显式实例化。</p></li></ul><p>显式具体化：</p><p>一种模板定义，实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>&amp;, <span class="hljs-type">int</span>&amp;)&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>或：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;, <span class="hljs-type">int</span>&amp;)</span></span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>意为“当实参为两个int类型时，不要使用Swap()模板来生成函数定义，而应使用专门为int类型显式地定义地具体函数”。</p><h4 id="2-动态多态"><a href="#2-动态多态" class="headerlink" title="2.动态多态"></a>2.动态多态</h4><p>动态多态主要通过继承重写基类的虚函数实现，在程序运行时根据基类的指针（或引用）指向的对象来确定自己具体调用哪一个类的虚函数。</p><h2 id="类的4个默认函数"><a href="#类的4个默认函数" class="headerlink" title="类的4个默认函数"></a>类的4个默认函数</h2><p>类的4个默认函数分别为构造函数、析构函数、拷贝函数和赋值函数。通常来讲，1个类包含多个构造函数（由1个或多个普通构造函数与1个拷贝构造函数组成）、1个赋值函数和1个析构函数。若不编写上述函数，C++编译器会自动为类产生4个缺省的函数。然而，使用默认的构造函数与析构函数，相当于放弃了自主“初始化”与“清除”机会。同时，默认的拷贝构造函数、赋值函数采用“位拷贝”而非“值拷贝”，类中含指针变量时将出错。</p><h4 id="1-构造函数："><a href="#1-构造函数：" class="headerlink" title="1. 构造函数："></a>1. 构造函数：</h4><p>构造函数是与类同名、无返回值的特殊成员函数，提供对成员变量初始化的方法。程序创建时将自动调用构造函数。</p><ul><li><p><strong>默认的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>() &#123;<br><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>默认构造函数无参，仅负责创建对象而不进行赋值操作。</p></li><li><p><strong>无参带赋值操作的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>() &#123;<br>name = <span class="hljs-string">&#x27;xiaoming&#x27;</span>;<br>        garde = <span class="hljs-number">90</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该函数将覆盖默认构造函数，它不仅创建对象还负责成员初始化。</p></li><li><p><strong>带参的带赋值操作的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> g) &#123;<br>name = n;<br>        garde = g;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该构造函数也将覆盖默认的构造函数。</p><p><strong>注意：</strong>一旦类中只包含带参的构造函数而不包含不带参的构造函数时，将无法创建不带参数的对象，程序将报错。</p><p><strong>解决办法：</strong>手动写一个默认构造函数，或给带参函数赋默认参数。</p></li></ul><p><strong>也可通过初始化表进行初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> g): <span class="hljs-built_in">name</span>(x), <span class="hljs-built_in">grade</span>(g) &#123;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-拷贝构造函数-amp-赋值函数："><a href="#2-拷贝构造函数-amp-赋值函数：" class="headerlink" title="2. 拷贝构造函数 &amp; 赋值函数："></a>2. 拷贝构造函数 &amp; 赋值函数：</h4><p>默认的拷贝构造函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Student(<span class="hljs-params">const</span> Student&amp; <span class="hljs-params">stu</span>)</span><br></code></pre></td></tr></table></figure><p>默认的赋值函数：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Student<span class="hljs-meta">&amp; operater=(const Student&amp; stu)</span><br></code></pre></td></tr></table></figure><p>拷贝构造函数是在创建对象时调用，而赋值函数只能被已存在的对象调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;world&quot;</span>)</span></span>;<br>string c = a; <span class="hljs-comment">//调用了拷贝构造函数，也可写成stirng c(a);</span><br>c = b; <span class="hljs-comment">//调用了赋值函数 </span><br></code></pre></td></tr></table></figure><h4 id="3-析构函数："><a href="#3-析构函数：" class="headerlink" title="3.析构函数："></a>3.析构函数：</h4><p>也是无参无返回类型的特殊成员函数，但它不能随意调用，没有重载，只有在类对象的生命期结束时，由系统自动调用，用来在系统释放对象前做一些清理工作。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/2022/01/28/MyFirstBlog/"/>
    <url>/2022/01/28/MyFirstBlog/</url>
    
    <content type="html"><![CDATA[<p>深夜被一些诡异的报错反复折磨，气到重装Ubuntu。漫长的安装等待中想到，要不边等边把个人博客给建了吧，于是一通操作就有了现在的这篇blog。</p><p>鉴于本人的菜鸡水平应该也没办法分享出什么技术，这个博客大概就是给自己的各种笔记啥的找个归属地。</p><p>所以本人的寒假又多了点乐子：把博客建得像模像样一点（误</p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
