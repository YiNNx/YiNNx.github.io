<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Note for Pygame</title>
    <link href="/2022/02/16/Pygame/"/>
    <url>/2022/02/16/Pygame/</url>
    
    <content type="html"><![CDATA[<h1 id="Pygame"><a href="#Pygame" class="headerlink" title="Pygame"></a>Pygame</h1><blockquote><p><a href="https://www.pygame.org/docs/">官方文档 </a></p></blockquote><h3 id="1-模块常用内容"><a href="#1-模块常用内容" class="headerlink" title="1.模块常用内容"></a>1.模块常用内容</h3><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><ul><li><strong>init()：</strong> 初始化程序</li><li><strong>quit()：</strong> 卸载所有模块</li></ul><h4 id="子模块-amp-函数："><a href="#子模块-amp-函数：" class="headerlink" title="子模块 &amp; 函数："></a>子模块 &amp; 函数：</h4><ul><li><strong>display模块</strong><ul><li><strong>set_caption()</strong> ：设置窗口标题</li><li><strong>set_mode()</strong> ：创建图形类型Surface对象</li><li><strong>set_icon()</strong> ：设置左上角的游戏图标，图标尺寸大小为 32*32。</li><li><strong>flip()</strong> ：更新屏幕内容</li></ul></li><li><strong>event模块</strong><ul><li><strong>get()</strong> ：获取事件</li></ul></li><li><strong>font模块</strong><ul><li><strong>Font()</strong> ：创建Font对象</li></ul></li><li><strong>time模块</strong><ul><li><strong>pygame.time.get_ticks()</strong> ：以毫秒为单位获取时间</li><li><strong>pygame.time.wait()</strong> ：使程序暂停一段时间</li><li><strong>pygame.time.set_timer()</strong> ：创建一个定时器，即每隔一段时间，去执行一些动作</li><li><strong>pygame.time.Clock()</strong> ：创建一个时钟对象来帮我们确定游戏要以多大的帧数运行</li></ul></li><li><strong>image模块</strong><ul><li><strong>load()</strong> ：将图像返回为一个Surface对象</li></ul></li></ul><h4 id="类-amp-方法："><a href="#类-amp-方法：" class="headerlink" title="类 &amp; 方法："></a>类 &amp; 方法：</h4><ul><li><p><strong>Surface类</strong></p><ul><li><strong>Surface(size&#x3D;(width,height),flags,depth)</strong> ：创建一个surface类</li><li><strong>fill()</strong> ：填充颜色</li><li><strong>set_alpha()</strong> ：设置整个图像的透明度</li><li><strong>blit()</strong> ：拼接Surface对象，第一个参数为一个Surface对象表内容，第二个参数为一个Rect对象表位置</li><li><strong>scroll()</strong> ：复制并移动 Surface 对象</li><li><strong>subsurface()</strong> ：根据父对象创建一个新的子 Surface 对象</li><li><strong>get_rect()</strong> ：获得自身表rect区域坐标的Rect对象</li></ul></li><li><p><strong>Font类</strong></p><ul><li><strong>render()</strong> ：创建文本类型Surface对象</li></ul></li><li><p><strong>Rect类</strong></p><ul><li><strong>Rect(left,top,width,height)</strong> ：创建一个Rect类，表示窗口上的一块矩形区域</li><li><strong>center</strong>：表显示中心坐标</li></ul></li><li><p><strong>Event类</strong></p><ul><li><strong>type</strong></li></ul></li></ul><h3 id="2-初始化程序"><a href="#2-初始化程序" class="headerlink" title="2. 初始化程序"></a>2. 初始化程序</h3><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python">pygame.init()<br></code></pre></td></tr></table></figure><p>它的作用是自动检测 Pygame 软件包是否正常可用，并检查电脑的硬件调用接口、基础功能是否存在问题，比如音频、光驱、声卡驱动等设备。同时，它会完成 <strong>Pygame 中所有模块的初始化操作</strong>，比如 display（显示模块）、font（字体模块）、mixer（声音控制模块）、cursors（光标控制模块）等。</p><h3 id="3-创建Surface对象"><a href="#3-创建Surface对象" class="headerlink" title="3. 创建Surface对象"></a>3. 创建Surface对象</h3><p><strong>创建一个 surface 对象：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">screen = pygame.display.set_mode((<span class="hljs-number">800</span>,<span class="hljs-number">600</span>))<br></code></pre></td></tr></table></figure><p><strong>设置背景颜色</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">screen</span>.fill((<span class="hljs-number">138</span>,<span class="hljs-number">151</span>,<span class="hljs-number">146</span>))<br></code></pre></td></tr></table></figure><p>screen 是一个 Surface 对象，它是游戏的主窗口，任何其他的 Surface 对象都需要附着于此。</p><p>创建包含文本的 Surface 对象，然后将它绘制在主屏幕上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建一个包含文字的Surface对象</span><br>text = f.render(<span class="hljs-string">&quot;Hello, world!&quot;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>))<br><span class="hljs-comment">#通过blit方法将其绘制在主屏幕上，textRect表示位置坐标</span><br>screen.blit(text,textRect)<br></code></pre></td></tr></table></figure><p><strong>创建一个图像的Surface对象</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">surface_image =pygame.image.load(<span class="hljs-string">&quot;图片路径&quot;</span>) <br></code></pre></td></tr></table></figure><h3 id="4-事件监听"><a href="#4-事件监听" class="headerlink" title="4. 事件监听"></a>4. 事件监听</h3><p>Pygame 提供了一个 event 模块，这个模块中包含了所有常用到游戏事件。如退出游戏：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 循环获取事件，监听事件状态，使用get()获取事件</span><br><span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br><span class="hljs-comment"># 判断事件类型，用户是否点了&quot;X&quot;关闭按钮(pygame.QUIT)</span><br><span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:   <br>pygame.quit()<br></code></pre></td></tr></table></figure><h3 id="5-游戏循环"><a href="#5-游戏循环" class="headerlink" title="5. 游戏循环"></a>5. 游戏循环</h3><p>如果想要达到“循环监听”目的，需要设置一个游戏循环（Game Loop）也称为游戏的主循环。一个最基本的只包含退出操作的主循环如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <br>    <span class="hljs-comment"># 循环获取事件，监听事件    </span><br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():        <br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:            <br>        <span class="hljs-comment"># 当用户关闭游戏窗口时执行以下操作            </span><br>            pygame.quit()                   <br>            sys.exit()    <br>    <span class="hljs-comment">#更新并绘制屏幕内容    </span><br>    pygame.display.flip() <br></code></pre></td></tr></table></figure><p>游戏主循环主要承担以下任务：</p><ul><li>处理游戏事件</li><li>更新游戏状态</li><li>把更新后的游戏状态绘制到屏幕上</li></ul><p>游戏画面和游戏操作状态会因为动画效果和玩家的操作而改变，因此需要以循环的方式实时地更新主屏幕（screen）的显示内容。把下列代码放入游戏主循环中即可实现实时更新和绘制屏幕内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#刷新界面显示</span><br>pygame.display.flip() <br></code></pre></td></tr></table></figure><p>除了上述方法外，Pygame 还提供了另一个方法：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">pygame.<span class="hljs-keyword">display</span>.up<span class="hljs-meta">date</span>() <br></code></pre></td></tr></table></figure><p>这两个方法的主要区别是：后者可以根据选定的区域来更新部分内容，而前者则是更新整个待显示的内容。如果后者没有提供区域位置参数时，其作用和 display.flip() 相同。</p><h2 id="display模块"><a href="#display模块" class="headerlink" title="display模块"></a>display模块</h2><h4 id="创建游戏主窗口："><a href="#创建游戏主窗口：" class="headerlink" title="创建游戏主窗口："></a>创建游戏主窗口：</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">screen = pygame.display.<span class="hljs-built_in">set_mode</span>(size=(),flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>Display模块中的<code>set_mode()</code>函数负责创建Surface对象，它返回一个Surface对象，同时接收两个参数用于设置窗口大小和样式：</p><ul><li><strong>size：</strong>元组参数，用来设置主窗口的大小</li><li><strong>flags：</strong>功能标志位，表示创建的主窗口样式，比如创建全屏窗口、无边框窗口等，参数值如下</li></ul><table><thead><tr><th>标志位</th><th>功能</th></tr></thead><tbody><tr><td>pygame.FULLSCREEN</td><td>创建一个全屏窗口。</td></tr><tr><td>pygame.HWSURFACE</td><td>创建一个硬件加速窗口，必须和 FULLSCREEN 同时使用。</td></tr><tr><td>pygame.OPENGL</td><td>创建一个 <a href="https://baike.baidu.com/item/OpenGL/238984">OPENGL</a> 渲染窗口。</td></tr><tr><td>pygame.RESIZABLE</td><td>创建一个可以改变大小的窗口。</td></tr><tr><td>pygame.DOUBLEBUF</td><td>创建一个双缓冲区窗口，建议在HWSURFACE 或者 OPENGL 时使用。</td></tr><tr><td>pygame.NOFRAME</td><td>创建一个没有边框的窗口。</td></tr></tbody></table><p>在主窗口中，我们还可以添加各种小的 Surface 对象，这些对象以矩形的形式存在于主窗口中，它们共同组成了一个游戏程序。通过blit方法将一个 Surface 对象粘贴至主窗口上：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">screen.blit(source, dest, <span class="hljs-built_in">area</span>=<span class="hljs-built_in">None</span>, special_flags = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>上述参数的内容：</p><ul><li>source：表示要粘贴的 Surface 对象。</li><li>dest：主窗口中的一个标识的坐标位置，可以接受一个 (x,y) 元组，或者 (x,y,width,height) 元组，也可以是一个 Rect 对象；</li><li>area：接受一个 Rect 对象，默认为 None，如果提供该参数则相当于抠图操作，即在屏幕的指定区域显示想要的内容；</li><li>special_flags：可选参数，它是 Pygame.1.8 版本新增的功能，用于指定对应位置颜色的混合方式，参数值有 BLEND_RGBA_ADD、BLEND_SUB 等。如果不提供该参数的情况下，默认使用 source 的颜色覆盖 screen 的颜色。</li></ul><h4 id="display模块函数："><a href="#display模块函数：" class="headerlink" title="display模块函数："></a>display模块函数：</h4><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>pygame.display.get_surface()</td><td>获取当前显示的 Surface 对象。</td></tr><tr><td>pygame.display.flip()</td><td>更新整个待显示的 Surface 对象到屏幕上。</td></tr><tr><td>pygame.display.update()</td><td>更新部分软件界面显示。</td></tr><tr><td>pygame.display.Info()</td><td>产生一个 VideoInfo 对象，包含了显示界面的相关信息。</td></tr><tr><td>pygame.display.set_icon()</td><td>设置左上角的游戏图标，图标尺寸大小为 32*32。</td></tr><tr><td>pygame.display.iconify()</td><td>将显示的主窗口即 Surface 对象最小化，或者隐藏。</td></tr><tr><td>pygame.display.get_active()</td><td>当前显示界面显示在屏幕上时返回 True，如果窗口被隐藏和最小化则返回 False。</td></tr></tbody></table><p>应用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#设置主屏窗口</span><br>screen=pygame.display.set_mode((<span class="hljs-number">800</span>,<span class="hljs-number">600</span>))<br><br><span class="hljs-comment">#填充主窗口的背景颜色，参数值RGB（颜色元组）screen.fill((138,151,146))</span><br><br><span class="hljs-comment">#设置窗口标题</span><br>pygame.display.set_caption(<span class="hljs-string">&quot;hello!&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Surface类：创建图像"><a href="#Surface类：创建图像" class="headerlink" title="Surface类：创建图像"></a>Surface类：创建图像</h2><p>Pygame 针对文本、图像、颜色提供了不同模块来生成它们各自的 Surface 对象。</p><h4 id="Surface-函数"><a href="#Surface-函数" class="headerlink" title="Surface()函数"></a>Surface()函数</h4><p>是Pygame 中专门用来新建图像的，可以创建一个 Surface 对象，语法格式如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Surface=pygame.<span class="hljs-constructor">Surface(<span class="hljs-params">size</span>=(<span class="hljs-params">width</span>,<span class="hljs-params">height</span>)</span>,flags,depth)<br></code></pre></td></tr></table></figure><p>参数函数如下：</p><ul><li>size：表示 Surface 对象的矩形区域大小；</li><li>flags：功能标志位，有两个可选参数值 HWSURFACE 和 SPCALPHA。HWSURFACE 代表将创建的 Surface 对象存放于显存中， SPCALPHA表示让图像的每一个像素都包含一个 alpha 通道</li><li>depth：指定像素的颜色深度，默认为自适应模式，由 Pygame 自动调节。</li></ul><h4 id="Surface类方法："><a href="#Surface类方法：" class="headerlink" title="Surface类方法："></a>Surface类方法：</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Surface.blit()</td><td>将一个图像（Surface 对象）绘制到另一个图像上</td></tr><tr><td>Surface.convert()</td><td>修改图像（Surface 对象）的像素格式</td></tr><tr><td>Surface.fill()</td><td>使用纯色填充 Surface 对象</td></tr><tr><td>Surface.scroll()</td><td>复制并移动 Surface 对象</td></tr><tr><td>Surface.set_alpha()</td><td>设置整个图像的透明度</td></tr><tr><td>Surface.get_at()</td><td>获取一个像素的颜色值</td></tr><tr><td>Surface.set_at()</td><td>设置一个像素的颜色值</td></tr><tr><td>Surface.get_palette()</td><td>获取 Surface 对象 8 位索引的调色板</td></tr><tr><td>Surface.map_rgb()</td><td>将一个 RGBA 颜色转换为映射的颜色值</td></tr><tr><td>Surface.set_clip()</td><td>设置该 Surface 对象的当前剪切区域</td></tr><tr><td>Surface.subsurface()</td><td>根据父对象创建一个新的子 Surface 对象</td></tr><tr><td>Surface.get_offset()</td><td>获取子 Surface 对象在父对象中的偏移位置</td></tr><tr><td>Surface.get_size()</td><td>获取 Surface 对象的尺寸</td></tr></tbody></table><h2 id="image模块"><a href="#image模块" class="headerlink" title="image模块"></a>image模块</h2><p>除了使用 Surface 模块新建图像外，另外一种从外部加载图像的方法：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">pygame.<span class="hljs-built_in">image</span>.<span class="hljs-built_in">load</span>(<span class="hljs-string">&quot;图片路径&quot;</span>).<span class="hljs-built_in">convert</span>()  <br></code></pre></td></tr></table></figure><p>该方法返回一个 Surface 对象。convert(）用于转换被加载图片的像素格式，从而提升 Pygame 对图片的处理速度，该操作能够保证图像的像素格式与图片的显示格式是相同的。</p><h2 id="transform-模块：图像变形"><a href="#transform-模块：图像变形" class="headerlink" title="transform 模块：图像变形"></a>transform 模块：图像变形</h2><p>transform 模块可以对加载、创建后的图像进行一系列操作，比如调整图像大小、旋转图片等：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.transform.scale()</td><td>将图片缩放至指定的大小，并返回一个新的 Surface 对象。</td></tr><tr><td>pygame.transform.rotate()</td><td>将图片旋转至指定的角度。</td></tr><tr><td>pygame.transform.rotozoom()</td><td>以角度旋转图像，同时将图像缩小或放大至指定的倍数。</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#加载一张图片（455*191)</span><br>image_surface = pygame.image.load(<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/4.png&quot;</span>).convert()<br>image_new = pygame.transform.scale(image_surface,(<span class="hljs-number">300</span>,<span class="hljs-number">300</span>))<br><br><span class="hljs-comment"># 对新生成的图像进行旋转至45度</span><br>image_1 =pygame.transform.rotate(image_new,<span class="hljs-number">45</span>)<br><br><span class="hljs-comment"># 使用rotozoom() 旋转 0 度，将图像缩小0.5倍</span><br>image_2 = pygame.transform.rotozoom(image_1,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><h2 id="time模块：时间控制"><a href="#time模块：时间控制" class="headerlink" title="time模块：时间控制"></a>time模块：时间控制</h2><p>time 模块主要用于管理时间和帧数率（即 FPS）。</p><p><strong>Point：</strong>Pygame 中时间以毫秒为单位（1秒&#x3D;1000毫秒）。</p><h3 id="1-游戏暂停"><a href="#1-游戏暂停" class="headerlink" title="1) 游戏暂停"></a>1) 游戏暂停</h3><p>常用方法如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.time.get_ticks()</td><td>以毫秒为单位获取时间</td></tr><tr><td>pygame.time.wait()</td><td>使程序暂停一段时间</td></tr><tr><td>pygame.time.set_timer()</td><td>创建一个定时器，即每隔一段时间，去执行一些动作</td></tr><tr><td>pygame.time.Clock()</td><td>创建一个时钟对象来帮我们确定游戏要以多大的帧数运行</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br>pygame.init()<br>screen = pygame.display.set_mode((<span class="hljs-number">500</span>,<span class="hljs-number">500</span>))<br><span class="hljs-comment"># 获取以毫秒为单位的时间</span><br>t = pygame.time.get_ticks() <span class="hljs-comment">#该时间指的从pygame初始化后开始计算，到调用该函数为止</span><br>t1 =pygame.time.wait(<span class="hljs-number">3000</span>) <span class="hljs-comment">#暂停游戏3000毫秒</span><br><span class="hljs-built_in">print</span>(t1)<br><span class="hljs-comment">#暂停t1时间后，加载图片</span><br>image_surface = pygame.image.load(<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/c-net.png&quot;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            exit()<br>    screen.blit(image_surface,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>    pygame.display.update()<br></code></pre></td></tr></table></figure><h3 id="2-设置游戏FPS"><a href="#2-设置游戏FPS" class="headerlink" title="2) 设置游戏FPS"></a>2) 设置游戏FPS</h3><p>设置游戏的帧数率（FPS）可通过 Clock() 方法来实现：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.time.Clock.tick()</td><td>更新clock对象</td></tr><tr><td>pygame.time.Clock.get_time()</td><td>获取上一个tick中的时间</td></tr><tr><td>pygame.time.Clock.get_fps()</td><td>计算clock对象的帧率</td></tr></tbody></table><p>下面看一组简单的应用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建时钟对象（控制游戏的FPS）</span><br>clock = pygame.time.Clock()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#通过时钟对象，指定循环频率，每秒循环60次</span><br>    clock.tick(<span class="hljs-number">60</span>)<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            exit()<br>    screen.blit(image_surface,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>    pygame.display.update()<br></code></pre></td></tr></table></figure><p>注意：FPS（游戏帧率）影响效果只有在动态图时才能显现出来，不过无论静态图还是动态图，它们的使用规则都是一样的。</p><h2 id="Rect类：区域位置"><a href="#Rect类：区域位置" class="headerlink" title="Rect类：区域位置"></a>Rect类：区域位置</h2><p>Rect（rectangle）指的是矩形，使用 Rect() 方法来创建一个指定位置，大小的矩形区域如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">rect =pygame.<span class="hljs-constructor">Rect(<span class="hljs-params">left</span>,<span class="hljs-params">top</span>,<span class="hljs-params">width</span>,<span class="hljs-params">height</span>)</span> <br></code></pre></td></tr></table></figure><p>Rect 表示的区域必须位于一个 Surface 对象之上，比如游戏的主窗口。</p><p><strong>Point</strong>：在 Pygame 中以游戏主窗口的左上角为坐标原点。</p><p>下面看一组简单的使用示例，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">image_surface = pygame.image.load(<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/c-net.png&quot;</span>)<br><br>rect1 = pygame.Rect(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)<br><span class="hljs-comment"># 在原图的基础上创建一个新的子图（surface对象）</span><br>image_child= image_surface.subsurface(rect1)<br><br>rect2 = image_child.get_rect()<br><span class="hljs-comment">#输出的矩形大小为 100*100</span><br><span class="hljs-built_in">print</span>(rect2)<br><br>screen.blit(image_child,rect1)<br></code></pre></td></tr></table></figure><h4 id="Rect类方法："><a href="#Rect类方法：" class="headerlink" title="Rect类方法："></a>Rect类方法：</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.Rect.copy()</td><td>复制矩形</td></tr><tr><td>pygame.Rect.move()</td><td>移动矩形区域，接受一个列表参数</td></tr><tr><td>pygame.Rect.move_ip()</td><td>移动矩形（无返回）</td></tr><tr><td>pygame.Rect.inflate()</td><td>增大或缩小矩形大小</td></tr><tr><td>pygame.Rect.clamp()</td><td>将矩形移到另一个矩形内</td></tr><tr><td>pygame.Rect.union()</td><td>返回一个两个矩形合并后的矩形。</td></tr><tr><td>pygame.Rect.fit()</td><td>按纵横比调整矩形的大小或移动矩形。</td></tr><tr><td>pygame.Rect.contains()</td><td>测试一个矩形是否在另一个矩形内</td></tr><tr><td>pygame.Rect.collidepoint()</td><td>测试点是否在矩形内</td></tr><tr><td>pygame.Rect.colliderect()</td><td>测试两个矩形是否重叠</td></tr></tbody></table><h4 id="Rect类属性："><a href="#Rect类属性：" class="headerlink" title="Rect类属性："></a>Rect类属性：</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>x,y</td><td>表示矩形距离 x、y 轴的距离</td></tr><tr><td>top, left, bottom, right</td><td>在坐标系内描述矩形的大小</td></tr><tr><td>topleft, bottomleft, topright, bottomright</td><td>描述矩形大小的坐标</td></tr><tr><td>midtop, midleft, midbottom, midright</td><td>描述矩形大小的坐标</td></tr><tr><td>center, centerx, centery</td><td>(centerx，centery)表示矩形中央坐标(x,y)的值</td></tr><tr><td>w,h</td><td>用于描述矩形的width、height</td></tr></tbody></table><p>可通过属性对来设置更改矩形区域的大小：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">rect1.left</span> = <span class="hljs-number">30</span> <br><span class="hljs-attr">rect1.center</span> = (<span class="hljs-number">70</span>,<span class="hljs-number">70</span>)<br></code></pre></td></tr></table></figure><p>除了通过 Rect 对象来构造一个矩形区域之外，还可以使用<code>rect</code>属性来构建一个矩形区域。在 Pygame 中有许多函数都提供了<code>rect</code>属性，比如有下列函数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">surface</span>.fill((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>),rect=(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">50</span>))<br></code></pre></td></tr></table></figure><p>上述代码会在 surface 对象的区域内选定一个 rect 区域，并将该区域填充为蓝色（RGB(0,0,255)）。</p><h2 id="event模块"><a href="#event模块" class="headerlink" title="event模块"></a>event模块</h2><p>事件（Event）是构建整个游戏程序的核心，比如鼠标点击、键盘敲击、游戏窗口移动、调整窗口大小、触发特定的情节、退出游戏等。<strong>Pygame 定义了一个专门用来处理事件的结构，即事件队列</strong>。该结构遵循队列“先进先出”的基本原则，通过事件队列，我们可以有序的、逐一的处理用户的操作。</p><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>以下是 Pygame 中常用游戏事件，它们都被定义为pygame模块中的常量：</p><table><thead><tr><th>事件类型</th><th>描述</th><th>成员属性</th></tr></thead><tbody><tr><td>QUIT</td><td>按下窗口的关闭按钮</td><td>none</td></tr><tr><td>ATIVEEVENT</td><td>Pygame被激活或者隐藏</td><td>gain,state</td></tr><tr><td>KEYDOWN</td><td>键盘按下</td><td>unicode、key、mod</td></tr><tr><td>KEYUP</td><td>键盘放开</td><td>key、mod</td></tr><tr><td>MOUSEMOTION</td><td>鼠标移动</td><td>pos, rel, buttons</td></tr><tr><td>MOUSEBUTTONDOWN</td><td>鼠标按下</td><td>pos, button</td></tr><tr><td>MOUSEBUTTONUP</td><td>鼠标放开</td><td>pos, button</td></tr><tr><td>VIDEORESIZE</td><td>Pygame窗口缩放</td><td>size, w, h</td></tr><tr><td>VIDEOEXPOSE</td><td>Pygame窗口部分公开(expose)</td><td>none</td></tr><tr><td>USEREVENT</td><td>触发一个用户事件</td><td>事件代码</td></tr></tbody></table><h3 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h3><p>event 模块中处理事件队列的常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.event.get()</td><td>从事件队列中获取一个事件，并从队列中删除该事件</td></tr><tr><td>pygame.event.wait()</td><td>阻塞直至事件发生才会继续执行，若没有事件发生将一直处于阻塞状态</td></tr><tr><td>pygame.event.set_blocked()</td><td>控制哪些事件禁止进入队列，如果参数值为None，则表示禁止所有事件进入</td></tr><tr><td>pygame.event.set_allowed()</td><td>控制哪些事件允许进入队列</td></tr><tr><td>pygame.event.pump()</td><td>调用该方法后，Pygame 会自动处理事件队列</td></tr><tr><td>pygame.event.poll()</td><td>会根据实际情形返回一个真实的事件，或者一个None</td></tr><tr><td>pygame.event.peek()</td><td>检测某类型事件是否在队列中</td></tr><tr><td>pygame.event.clear()</td><td>从队列中清除所有的事件</td></tr><tr><td>pygame.event.get_blocked()</td><td>检测某一类型的事件是否被禁止进入队列</td></tr><tr><td>pygame.event.post()</td><td>放置一个新的事件到队列中</td></tr><tr><td>pygame.event.Event()</td><td>创建一个用户自定义的新事件</td></tr></tbody></table><p>当我们使用 Pygame 处理事件时，逻辑一般都是相似的。首先是判断事件的类型，然后根据不同的事件操作，执行不同的游戏操作。因此这种情况非常适合使用 if … else 语句。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#等待事件发生</span><br>    event = pygame.event.wait()<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>        exit()<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEBUTTONDOWN:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标按下&#x27;</span>,event.pos)<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEBUTTONUP:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标弹起&#x27;</span>)<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEMOTION:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标移动&#x27;</span>)<br>        <span class="hljs-comment"># 键盘事件</span><br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> ==pygame.KEYDOWN:<br>        <span class="hljs-comment"># 打印按键的英文字符</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘按下&#x27;</span>,<span class="hljs-built_in">chr</span>(event.key))<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.KEYUP:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘弹起&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="处理键盘事件"><a href="#处理键盘事件" class="headerlink" title="处理键盘事件"></a>处理键盘事件</h3><p>键盘事件提供了一个 key 属性，通过该属性可以获取键盘的按键。Pygame 将键盘上的字母键、数字键、组合键等按键以常量的方式进行了定义，下表列出了部分常用按键的常量：</p><table><thead><tr><th>常量名</th><th>描述</th></tr></thead><tbody><tr><td>K_BACKSPACE</td><td>退格键（Backspace）</td></tr><tr><td>K_TAB</td><td>制表键（Tab）</td></tr><tr><td>K_CLEAR</td><td>清除键（Clear）</td></tr><tr><td>K_RETURN</td><td>回车键（Enter）</td></tr><tr><td>K_PAUSE</td><td>暂停键（Pause）</td></tr><tr><td>K_ESCAPE</td><td>退出键（Escape）</td></tr><tr><td>K_SPACE</td><td>空格键（Space）</td></tr><tr><td>K_0…K_9</td><td>0…9</td></tr><tr><td>K_a…Kz</td><td>a…z</td></tr><tr><td>K_DELETE</td><td>删除键（delete）</td></tr><tr><td>K_KP0…K_KP9</td><td>0（小键盘）…9（小键盘）</td></tr><tr><td>K_F1…K_F15</td><td>F1…F15</td></tr><tr><td>K_UP</td><td>向上箭头（up arrow）</td></tr><tr><td>K_DOWN</td><td>向下箭头（down arrow）</td></tr><tr><td>K_RIGHT</td><td>向右箭头（right arrow）</td></tr><tr><td>K_LEFT</td><td>向左箭头（left arrow）</td></tr><tr><td>KMOD_ALT</td><td>同时按下Alt键</td></tr></tbody></table><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">while</span> True:<br>    site = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.type == pygame.QUIT:<br>            sys.<span class="hljs-keyword">exit</span>()<br>        <span class="hljs-comment"># 图像移动 KEYDOWN 键盘按下事件</span><br>        <span class="hljs-comment"># 通过 key 属性对应按键</span><br>        <span class="hljs-keyword">if</span> event.type == pygame.KEYDOWN:<br>            <span class="hljs-keyword">if</span> event.key == pygame.K_UP:<br>                site[<span class="hljs-number">1</span>] -= <span class="hljs-number">8</span><br>            <span class="hljs-keyword">if</span> event.key == pygame.K_DOWN:<br>                site[<span class="hljs-number">1</span>] += <span class="hljs-number">8</span><br>            <span class="hljs-keyword">if</span> event.key == pygame.K_LEFT:<br>                site[<span class="hljs-number">0</span>] -= <span class="hljs-number">8</span><br>            <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>                site[<span class="hljs-number">0</span>] += <span class="hljs-number">8</span><br>    <span class="hljs-comment"># 移动图像</span><br>    position = position.move(site)<br>    <span class="hljs-comment"># 填充背景</span><br>    screen.fill(bg)<br>    <span class="hljs-comment"># 放置图片</span><br>    screen.blit(img, position)<br>    <span class="hljs-comment"># 更新显示界面</span><br>    pygame.display.flip()<br></code></pre></td></tr></table></figure><h3 id="处理鼠标事件"><a href="#处理鼠标事件" class="headerlink" title="处理鼠标事件"></a>处理鼠标事件</h3><p>Pygame 提供了以下三个鼠标事件，不同事件类型对应着不同的Event类成员属性:</p><p><strong>pygame.MOUSEMOTION鼠标移动事件</strong></p><ul><li>Event.pos： 相对于窗口左上角，鼠标的当前坐标值(x,y)</li><li>Event.rel： 鼠标相对运动距离(X,Y)，相对于上次事件</li><li>Event.buttons： 鼠标按钮初始状态(0,0,0)，分别对应(左键,滑轮,右键)，移动过程中点击那个键，相应位置变会为1</li></ul><p><strong>pygame.MOUSEBUTTONUP鼠标键释放事件</strong></p><ul><li><p>Event.pos： 相对于窗口左上角，鼠标的当前坐标值(x,y)</p></li><li><p>Event.button: 鼠标释放键编号（整数）左键为1，按下滚动轮2、右键为3</p></li></ul><p><strong>pygame.MOUSEBUTTONDOWN 鼠标键按下事件</strong></p><ul><li>Event.pos： 相对于窗口左上角，鼠标的当前坐标值(x,y)</li><li>Event.button： 鼠标按下键编号（整数），左键为1，按下滚动轮2、右键为3，向前滚动滑轮4、向后滚动滑轮5</li></ul><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">while</span> True:<br>    <span class="hljs-comment">#等待事件发生</span><br>    event = pygame.event.wait()<br>    <span class="hljs-keyword">if</span> event.type == pygame.QUIT:<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;成功退出&quot;</span>)<br>    <span class="hljs-keyword">if</span> event.type == pygame.MOUSEBUTTONDOWN:<br>        <span class="hljs-comment"># pos 获取鼠标当前位置</span><br>        print(<span class="hljs-string">&#x27;鼠标按下&#x27;</span>,event.pos)<br>        mx,my = event.pos<br>        <span class="hljs-comment"># 调用 pygame.draw 模块画圆</span><br>        pygame.draw.circle(screen,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),(mx,my),<span class="hljs-number">50</span>)<br>        <span class="hljs-comment"># 处理完，更新显示</span><br>        pygame.display.update()<br>    <span class="hljs-keyword">if</span> event.type == pygame.MOUSEBUTTONUP:<br>        print(<span class="hljs-string">&#x27;鼠标弹起&#x27;</span>)<br>        pass<br>    <span class="hljs-keyword">if</span> event.type == pygame.MOUSEMOTION:<br>        print(<span class="hljs-string">&#x27;鼠标移动&#x27;</span>)<br>        mx, my = event.pos<br>        <span class="hljs-comment"># 随机生成 RGB 颜色值</span><br>        r = randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>        g = randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>        b = randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>        pygame.draw.circle(screen, (r,g,b,),(mx, my), <span class="hljs-number">50</span>)<br>        <span class="hljs-comment"># 处理完，更新显示</span><br>        pygame.display.update()<br></code></pre></td></tr></table></figure><h2 id="draw模块"><a href="#draw模块" class="headerlink" title="draw模块"></a>draw模块</h2><p>Pygame 中提供了一个<code>draw</code>模块用来绘制一些简单的图形。<code>draw</code>模块常用方法如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.draw.rect(surface, color, rect, width)</td><td>绘制矩形。当 width &gt; 0 时，表示线框的宽度；而 width &lt; 0 时，此时不会绘制任何图形。</td></tr><tr><td>pygame.draw.polygon(surface, color, points, width)</td><td>绘制多边形。其中 points 一个列表参数，它表示组成多边形顶点的 3 或者多个 (x,y) 坐标，通过元组或者列表来表示这些多边形顶点。</td></tr><tr><td>pygame.draw.circle(surface, color, pos, radius, width&#x3D;0)</td><td>根据圆心和半径绘制圆形。pos：该参数用来指定的圆心位置。radius：用来指定圆的半径。</td></tr><tr><td>pygame.draw.ellipse(surface, color, Rect, width&#x3D;0)</td><td>绘制一个椭圆形</td></tr><tr><td>pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width&#x3D;1)</td><td>绘制弧线（挥着椭圆的一部分）</td></tr><tr><td>pygame.draw.line(surface, color, start_pos, end_pos, width&#x3D;1)</td><td>绘制线段（直线）。start_pos 和 end_pos 表示线段的起始位置，此处使用 [x,y] 来表示起始位置。width &#x3D;1 表示直线的宽度，默认为 1。</td></tr><tr><td>pygame.draw.lines(surface, color, closed, pointlist, width&#x3D;1)</td><td>绘制多条连续的线段。pointlist：参数值为列表，包含了一些列点坐标的列表。closed：布尔值参数，如果设置为 True，表示直线的第一个端点和直线的最后一个端点要首尾相连。</td></tr><tr><td>pygame.draw.aaline(surface, color, startpos, endpos, blend&#x3D;1)</td><td>绘制一条平滑的线段（抗锯齿）</td></tr><tr><td>pygame.draw.aalines()</td><td>绘制多条连续的线段。blend 参数表示通过绘制混合背景的阴影来实现抗锯齿功能。</td></tr></tbody></table><p>表格中的函数都可以在 Surface 对象上绘制一些简单的形状，返回值是一个 Rect 对象，表示实际绘制图形的矩形区域。上述绘图函数都提供了一个 color 参数，可以通过以下三种方式来传递 color 参数值：</p><ul><li>使用 pygame.color 对象</li><li>RGB 三元组</li><li>RGBA 四元组</li></ul><h2 id="font模块：文本和字体"><a href="#font模块：文本和字体" class="headerlink" title="font模块：文本和字体"></a>font模块：文本和字体</h2><p><code>pygame.font</code>模块常用方法如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.font.init()</td><td>初始化字体模块</td></tr><tr><td>pygame.font.quit()</td><td>取消初始化字体模块</td></tr><tr><td>pygame.font.get_init()</td><td>检查字体模块是否被初始化，返回一个布尔值。</td></tr><tr><td>pygame.font.get_default_font()</td><td>获得默认字体的文件名。返回系统中字体的文件名</td></tr><tr><td>pygame.font.get_fonts()</td><td>获取所有可使用的字体，返回值是所有可用的字体列表</td></tr><tr><td>pygame.font.match_font()</td><td>从系统的字体库中匹配字体文件，返回值是完整的字体文件路径</td></tr><tr><td>pygame.font.SysFont()</td><td>从系统的字体库中创建一个 Font 对象</td></tr><tr><td>pygame.font.Font()</td><td>从一个字体文件创建一个 Font 对象</td></tr></tbody></table><p>Font 模块提供了两种创建Font类对象的方法，分别是：</p><ul><li>SysFont（从系统中加载字体文件创建字体对象）</li><li>Font（通过文件路径创建字体对象）</li></ul><h4 id="1-font-SysFont"><a href="#1-font-SysFont" class="headerlink" title="1) font.SysFont()"></a>1) font.SysFont()</h4><p>直接从系统中加载字体使用如下方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pygame.font.SysFont(name, size, <span class="hljs-attribute">bold</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">italic</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li><p>name：列表参数值，表示要从系统中加载的字体名称，它会按照列表中的元素顺序依次搜索，如果系统中没有列表中的字体，将使用 Pygame 默认的字体。</p></li><li><p>size：表示字体的大小；</p></li><li><p>bold：字体是否加粗；</p></li><li><p>italic：字体是否为斜体。</p></li></ul><p><strong>获取系统字体列表：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(pygame.font.get_fonts())<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">输出：</span><br><span class="hljs-string">[&#x27;arial&#x27;, &#x27;arialblack&#x27;, &#x27;bahnschrift&#x27;, &#x27;calibri&#x27;, &#x27;cambria&#x27;, &#x27;cambriamath&#x27;, &#x27;candara&#x27;, &#x27;comicsansms&#x27;, &#x27;consolas&#x27;, &#x27;constantia&#x27;, &#x27;corbel&#x27;, &#x27;couriernew&#x27;, &#x27;ebrima&#x27;, &#x27;franklingothicmedium&#x27;, &#x27;gabriola&#x27;, &#x27;gadugi&#x27;, &#x27;georgia&#x27;, &#x27;impact&#x27;, &#x27;inkfree&#x27;, &#x27;javanesetext&#x27;, &#x27;leelawadeeui&#x27;, &#x27;leelawadeeuisemilight&#x27;, &#x27;lucidaconsole&#x27;, &#x27;lucidasans&#x27;, &#x27;mal&#x27;, &#x27;franklingothicdemi&#x27;, &#x27;franklingothicdemicond&#x27;, &#x27;franklingothicheavy&#x27;, &#x27;franklingothicmediumcond&#x27;, &#x27;freestylescript&#x27;, &#x27;frenchscript&#x27;, &#x27;footlight&#x27;, &#x27;方正舒体&#x27;, &#x27;方正姚体&#x27;, &#x27;garamond&#x27;, &#x27;gigi&#x27;, &#x27;gillsans&#x27;, &#x27;gillsanscondensed&#x27;, &#x27;gillsansultracondensed&#x27;, &#x27;gillsansultra&#x27;, &#x27;gloucesterextracondensed&#x27;, &#x27;gillsansextcondensed&#x27;, &#x27;centurygothic&#x27;, &#x27;goudyoldstyle&#x27;, &#x27;goudystout&#x27;, &#x27;harlowsolid&#x27;, &#x27;harrington&#x27;, &#x27;haettenschweiler&#x27;, &#x27;hightowertext&#x27;, &#x27;imprintshadow&#x27;, &#x27;informalroman&#x27;, &#x27;blackadderitc&#x27;, &#x27;edwardianscriptitc&#x27;, &#x27;kristenitc&#x27;, &#x27;jokerman&#x27;, &#x27;juiceitc&#x27;, &#x27;kunstlerscript&#x27;, &#x27;widelatin&#x27;, &#x27;lucidabright&#x27;, &#x27;lucidacalligraphy&#x27;, &#x27;leelawadee&#x27;, &#x27;lucidafaxregular&#x27;, &#x27;lucidafax&#x27;, &#x27;lucidahandwriting&#x27;, &#x27;lucidasansregular&#x27;, &#x27;lucidasansroman&#x27;, &#x27;lucidasanstypewriterregular&#x27;, &#x27;lucidasanstypewriter&#x27;, &#x27;lucidasanstypewriteroblique&#x27;, &#x27;magneto&#x27;, &#x27;maiandragd&#x27;, &#x27;maturascriptcapitals&#x27;, &#x27;mistral&#x27;, &#x27;modernno20&#x27;, &#x27;microsoftuighur&#x27;, &#x27;monotypecorsiva&#x27;, &#x27;niagaraengraved&#x27;, &#x27;niagarasolid&#x27;, &#x27;ocraextended&#x27;, &#x27;oldenglishtext&#x27;, &#x27;onyx&#x27;, &#x27;msoutlook&#x27;, &#x27;palacescript&#x27;, &#x27;papyrus&#x27;, &#x27;parchment&#x27;, &#x27;perpetua&#x27;, &#x27;perpetuatitling&#x27;, &#x27;playbill&#x27;, &#x27;poorrichard&#x27;, &#x27;pristina&#x27;, &#x27;rage&#x27;, &#x27;ravie&#x27;, &#x27;msreferencesansserif&#x27;, &#x27;msreferencespecialty&#x27;, &#x27;rockwellcondensed&#x27;, &#x27;rockwell&#x27;, &#x27;rockwellextra&#x27;, &#x27;script&#x27;, &#x27;showcardgothic&#x27;, &#x27;隶书&#x27;, &#x27;幼圆&#x27;, &#x27;snapitc&#x27;, &#x27;华文彩云&#x27;, &#x27;stencil&#x27;, &#x27;华文仿宋&#x27;, &#x27;华文琥珀&#x27;, &#x27;华文楷体&#x27;, &#x27;华文隶书&#x27;, &#x27;华文宋体&#x27;, &#x27;华文细黑&#x27;, &#x27;华文行楷&#x27;, &#x27;华文新魏&#x27;, &#x27;华文中宋&#x27;, &#x27;twcen&#x27;, &#x27;twcencondensed&#x27;, &#x27;twcencondensedextra&#x27;, &#x27;tempussansitc&#x27;, &#x27;vinerhanditc&#x27;, &#x27;vivaldi&#x27;, &#x27;vladimirscript&#x27;, &#x27;wingdings2&#x27;, &#x27;wingdings3&#x27;, &#x27;&#x27;]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2-font-Font"><a href="#2-font-Font" class="headerlink" title="2) font.Font()"></a>2) font.Font()</h4><p>Font()可从外部加载字体文件来绘制文本：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">my_font = pygame.font.<span class="hljs-constructor">Font(<span class="hljs-params">filename</span>, <span class="hljs-params">size</span>)</span> <br></code></pre></td></tr></table></figure><ul><li>filename：字符串格式，表示字体文件的所在路径；</li><li>size：设置字体的大小。</li></ul><h4 id="3-字体对象方法"><a href="#3-字体对象方法" class="headerlink" title="3) 字体对象方法"></a>3) 字体对象方法</h4><p>Pygame 为处理字体对象提供了一些常用方法，如下所示：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.font.Font.render()</td><td>该函数创建一个渲染了文本的 Surface 对象</td></tr><tr><td>pygame.font.Font.size()</td><td>该函数返回渲染文本所需的尺寸大小，返回值是一个一元组 (width,height)</td></tr><tr><td>pygame.font.Font.set_bold()</td><td>启动粗体字渲染</td></tr><tr><td>pygame.font.Font.set_italic()</td><td>启动斜体字渲染</td></tr><tr><td>pygame.font.Font.metrics()</td><td>获取字符串中每一个字符的详细参数</td></tr><tr><td>pygame.font.Font.get_linesize()</td><td>获取字体文本的行高</td></tr><tr><td>pygame.font.Font.get_height()</td><td>获取字体的高度</td></tr><tr><td>pygame.font.Font.get_ascent()</td><td>获取字体顶端到基准线的距离</td></tr><tr><td>pygame.font.Font.get_descent()</td><td>获取字体底端到基准线的距离</td></tr></tbody></table><p>其中render()方法是绘制文本内容的关键：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">render</span>(<span class="hljs-keyword">text</span>, antialias, <span class="hljs-keyword">color</span>, background=None)<br></code></pre></td></tr></table></figure><ul><li>text：要绘制的文本内容</li><li>antialias：布尔值参数，是否是平滑字体（抗锯齿）。</li><li>color：设置字体颜色；</li><li>background：可选参数，默认为 None，该参数用来设置字体的背景颜色。</li></ul><h2 id="sprite模块：精灵和碰撞检测"><a href="#sprite模块：精灵和碰撞检测" class="headerlink" title="sprite模块：精灵和碰撞检测"></a>sprite模块：精灵和碰撞检测</h2><p>在一个游戏程序中，精灵（ Sprite）本质指的是一张张小尺寸的图片，比如游戏中的各种道具、人物、场景装饰等，它们都可以看做成一张张小的“精灵”图。除此之外，人物的移动也可以看做是一系列小精灵图构成的序列（按帧组成的序列）。</p><p>如果将逐帧分解后的动作，按照一定的频率播放，那么就形成了动画精灵。</p><p>精灵有个特点就是允许精灵之间进行交互，也称之为碰撞，而碰撞检测，指的就是检测两个精灵之间是否发生了碰撞。比如在贪吃蛇游戏中蛇的头部是否与食物发生了碰撞，或者飞机大战游戏中子弹是否击中了外星人等等。当检测到碰撞发生后，接下来会触发某些事件，比如子弹击中外星人，外星人就会消失，玩家的得分也会随之增加，并且在游戏屏幕上又会出现一个外星人。</p><p>Pygame 专门提供了一个处理精灵的模块，也就是 sprite模块。<strong>通常使用该模块的基类 Sprite 来创建一个子类，从而达到处理精灵的目的</strong> ，该子类提供了操作精灵的常用属性和方法，如下所示：</p><table><thead><tr><th>属性&amp;方法</th><th>说明</th></tr></thead><tbody><tr><td>self.image</td><td>加载要显示的精灵图片，控制图片大小和填充色</td></tr><tr><td>self.rect</td><td>精灵图片显示在哪个位置</td></tr><tr><td>Sprite.update()</td><td>刷新精灵图，使其相应效果生效</td></tr><tr><td>Sprite.add()</td><td>添加精灵图到精灵组中（groups）</td></tr><tr><td>Sprite.remove()</td><td>从精灵组中删除选中的精灵图</td></tr><tr><td>Sprite.kill()</td><td>删除精灵组中全部的精灵</td></tr><tr><td>Sprite.alive()</td><td>判断某个精灵是否属于精灵组</td></tr></tbody></table><p>当游戏中有大量的精灵时，操作它们将变得复杂，此时通过构建精灵容器（group 类）也就是精灵组来统一管理这些精灵。构建方法如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 创建精灵组</span><br><span class="hljs-keyword">group</span> <span class="hljs-title">= pygame</span>.sprite.Group()<br><span class="hljs-comment"># 向组内添加一个精灵</span><br>group.add(sprite_one)<br></code></pre></td></tr></table></figure><p>于此同时<code>pygame.sprite</code>模块也提供了多种检测精灵是否碰撞的方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.sprite.collide_rect()</td><td>两个精灵之间的矩形检测，即矩形区域是否有交汇，返回一个布尔值。</td></tr><tr><td>pygame.sprite.collide_circle()</td><td>两个精灵之间的圆形检测，即圆形区域是否有交汇，返回一个布尔值。</td></tr><tr><td>pygame.sprite.collide_mask()</td><td>两个精灵之间的像素蒙版检测，更为精准的一种检测方式。</td></tr><tr><td>pygame.sprite.spritecollide()</td><td>精灵和精灵组之间的矩形碰撞检测，一个组内的所有精灵会逐一地对另外一个单个精灵进行碰撞检测，返回值是一个列表，包含了发生碰撞的所有精灵。</td></tr><tr><td>pygame.sprite.spritecollideany()</td><td>精灵和精灵组之间的矩形碰撞检测，上述函数的变体，当发生碰撞时，返回组内的一个精灵，无碰撞发生时，返回 None。</td></tr><tr><td>pygame.sprite.groupcollide()</td><td>检测在两个组之间发生碰撞的所有精灵，它返回值是一个字典，将第一组中发生碰撞的精灵作为键，第二个组中发生碰撞的精灵作为值。</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span>(pygame.sprite.Sprite):<br>    <span class="hljs-comment">#定义构造函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,filename,location</span>):<br>        <span class="hljs-comment"># 调父类来初始化子类</span><br>        pygame.sprite.Sprite.__init__(self)<br>        <span class="hljs-comment"># 加载图片</span><br>        self.image = pygame.image.load(filename)<br>        <span class="hljs-comment"># 获取图片rect区域</span><br>        self.rect = self.image.get_rect()<br>        <span class="hljs-comment"># 设置位置</span><br>        self.rect.topleft=location<br><span class="hljs-comment"># 初始化pygame</span><br>pygame.init()<br>screen = pygame.display.set_mode((<span class="hljs-number">500</span>,<span class="hljs-number">400</span>))<br><br><span class="hljs-comment"># 填充为白色屏幕</span><br>screen.fill((<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>))<br>filename =<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/snake.png&quot;</span><br>location =(<span class="hljs-number">100</span>,<span class="hljs-number">150</span>)<br>snake1 = Snake(filename,location)<br><span class="hljs-comment"># 碰撞检测,必须有两个精灵，因此再创建一个精灵，并使用location来控制第二个精灵的位置</span><br>location_2 = (<span class="hljs-number">100</span>,<span class="hljs-number">80</span>)<br>snake2 = Snake(<span class="hljs-string">&#x27;C:/Users/Administrator/Desktop/logo.png&#x27;</span>,location_2)<br><span class="hljs-comment"># 调用 collide_rect()进行矩形区域检测，返回一个布尔值，碰撞返回True，否则返回False</span><br>crash_result = pygame.sprite.collide_rect(snake1,snake2)<br><span class="hljs-keyword">if</span> crash_result:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;精灵碰撞了!&quot;</span>)<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;精灵没碰撞&#x27;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            pygame.quit()<br>            exit()<br>    <span class="hljs-comment"># 绘制精灵到屏幕上</span><br>    screen.blit(snake1.image,snake1.rect)<br>    screen.blit(snake2.image,snake2.rect)<br>    <span class="hljs-comment"># 刷新显示屏幕</span><br>    pygame.display.update()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note for Python &amp; Pygame</title>
    <link href="/2022/02/10/PythonNote/"/>
    <url>/2022/02/10/PythonNote/</url>
    
    <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h3 id="动态语言-amp-静态语言："><a href="#动态语言-amp-静态语言：" class="headerlink" title="动态语言 &amp; 静态语言："></a>动态语言 &amp; 静态语言：</h3><ul><li><p><strong>动态语言：</strong>变量本身类型不固定。使用变量无需声明，但使用前必须赋值，赋值后变量才被创建。</p><p><strong>e.g. Python、Ruby、JavaScript</strong></p></li><li><p><strong>静态语言：</strong>变量类型固定。在定义变量时必须指定变量类型，赋值时变量与对象的类型必须相匹配or进行转化。</p><p><strong>e.g. Java、C、C++</strong></p></li></ul><blockquote><p>动态语言和静态语言很大的不同在于：函数和类的定义不是编译时定义的，而是运行时动态创建的。</p></blockquote><h3 id="引用赋值："><a href="#引用赋值：" class="headerlink" title="引用赋值："></a>引用赋值：</h3><p>像Python、JS这类动态语言，基本上都是使用引用赋值。在引用赋值中，变量名和真实值分开保存。变量名保存的是真实值的一个指针，对变量赋值时，也是将这个指针赋给新变量，原来的“引用”则断开了。</p><h3 id="Python中的不可变类型-amp-可变类型："><a href="#Python中的不可变类型-amp-可变类型：" class="headerlink" title="Python中的不可变类型 &amp; 可变类型："></a>Python中的不可变类型 &amp; 可变类型：</h3><ul><li><p><strong>不可变类型： Number、String、Tuple</strong></p><p>当变量为不可变类型时，无法在内存中直接修改这个变量（如：100、’hello‘）。如果尝试对不可变类型进行修改，就会断开原始的引用，重新指向新的对象。</p></li><li><p><strong>可变类型：List、Dictionary、Set</strong></p><p>可以在内存中进行修改，修改可变类型的值不会断开原始引用。</p></li></ul><h3 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h3><p>主动发起TCP链接，接收服务器返回数据，实现一次完整的网络通信。</p><p>以获取新浪首页HTML文件为例：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#tcp基本连接新浪首页获取并打印http头</span><br><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> ssl<br><br>s = ssl.wrap_socket(socket.socket())<br><br><span class="hljs-comment">#建立连接</span><br>s.connect((<span class="hljs-string">&#x27;www.sina.com.cn&#x27;</span>, <span class="hljs-number">443</span>))<br><br>s.send(<span class="hljs-string">b&quot;GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n&quot;</span>)<br><br><span class="hljs-comment">#接受数据</span><br>buf = []<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    d = s.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-keyword">if</span> d:<br>        buf.append(d)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br>data = <span class="hljs-string">b&quot;&quot;</span>.join(buf)<br><br><span class="hljs-comment">#关闭tcp连接</span><br>s.close()<br><br>data = data.split(<span class="hljs-string">b&#x27;\r\n\r\n&#x27;</span>,<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#打印请求头把流数据进行解码</span><br><span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span>].decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-comment">#写进文件html，存入本地文件夹</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:/SE/CODE/Python/sina.html&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(data[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iFleaBooks</title>
    <link href="/2022/02/06/iFleaBooks/"/>
    <url>/2022/02/06/iFleaBooks/</url>
    
    <content type="html"><![CDATA[<h1 id="iFleaBooks"><a href="#iFleaBooks" class="headerlink" title="iFleaBooks"></a>iFleaBooks</h1><p>Linux环境下的二手书交易系统</p><p>是一个C++练手项目，实现了较完整的交易系统前后台功能，包括用户注册、登录、浏览商品、发布商品、修改信息，管理员进行后台数据管理，本地数据载入与更新等，并基于Linux命令行进行交互。</p><p><strong>GitHub链接：</strong><a href="https://github.com/yinn-x/iFleaBooks">https://github.com/yinn-x/iFleaBooks</a></p><hr><h3 id="开发环境："><a href="#开发环境：" class="headerlink" title="开发环境："></a><strong>开发环境：</strong></h3><p>Ubuntu &amp; VS Code</p><h3 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a><strong>实现功能：</strong></h3><p><strong>User：</strong></p><ul><li>注册 &amp; 登录 &amp; 注销；</li><li>浏览书库 &#x2F; 搜索书籍 &amp; 查看书的详细信息；</li><li>购买二手书 &amp; 查看已购订单；</li><li>发布二手书 &amp; 修改详细信息；</li><li>下架自己的发布 &amp; 查看卖出订单；</li><li>个人信息管理 &amp; 钱包充值。</li></ul><p><strong>Admin：</strong></p><ul><li>查看 &#x2F; 检索所有书籍 &amp; 下架书籍；</li><li>查看和管理所有订单；</li><li>查看和管理所有用户信息。</li></ul><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a><strong>效果</strong>：</h3><p>登录界面 &amp; 注册 ：</p>  <img src="/img/iFleaBooks/11.png" style="zoom:50%;" /><p>​          </p><p>浏览界面：</p> <img src="/img/iFleaBooks/22.png" style="zoom:50%;" /><p>​           </p><p>买书界面：</p>  <img src="/img/iFleaBooks/2.png" style="zoom:50%;" /><p>​       </p><p>钱包充值：</p>  <img src="/img/iFleaBooks/3.png" style="zoom:50%;" /><p>​     </p><p>管理员界面：</p><img src="/img/iFleaBooks/4.png" style="zoom:50%;" /><p>​    </p><p>还有一堆界面懒得截了（雾</p>]]></content>
    
    
    <categories>
      
      <category>Projects</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note of C++ Primer</title>
    <link href="/2022/02/02/Note%20of%20C++%20Primer/"/>
    <url>/2022/02/02/Note%20of%20C++%20Primer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-从-C-到-C"><a href="#1-从-C-到-C" class="headerlink" title="1. 从 C 到 C++"></a>1. 从 C 到 C++</h1><p>一些 C++ 的新特性：</p><p><strong>多态：</strong></p><ul><li><p>静态多态：</p><p>（1）重载（函数重载 &amp; 运算符重载） </p><p>（2）泛型（函数模板 &amp; 类模板）</p></li><li><p>动态多态：虚函数</p></li></ul><p><strong>类：</strong></p><ul><li><p>继承（基类 &amp; 子类）</p></li><li><p>封装 （类访问修饰符 &amp; 友元）</p></li><li><p>其他细节：（1）类的默认函数</p><p>​                   （2）运算符重载</p><p>​                   （3）this 指针</p></li></ul><p><strong>其他：</strong></p><ul><li><p>引用变量</p></li><li><p>范围 for 语句</p></li><li><p>迭代器</p></li><li><p>内联函数</p></li><li><p>new &amp; delete</p></li><li><p>流式文件读写</p></li><li><p>函数的默认参数</p></li></ul><h2 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h2><h4 id="（1）泛型编程"><a href="#（1）泛型编程" class="headerlink" title="（1）泛型编程"></a>（1）泛型编程</h4><p>泛型编程在 C++ 中主要通过模板函数和模板类实现。</p><p>函数模板的性质：</p><ol><li>函数模板不是真正的函数，只是编译时生成具体函数的一个”模子”。</li><li>函数模板不是编译一份满足多重需要，而是为每一种替换它的函数编译生成一份新函数。</li></ol><p>函数模板的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span>&#123;<br>T t = a;<br>a = b, b = t;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>template用于声明开始泛型编程，typyname用于声明泛指类型。</p></li><li><p>自动类型推导调用:</p><p><code> Swap(a, b);</code> </p><p>该调用属于隐式实例化。</p></li><li><p>具体类型显式调用：</p><p><code>Swap&lt;int&gt;(a, b);</code></p><p>该调用属于显式实例化。</p></li></ul><p>显式具体化：</p><p>一种模板定义，实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>&amp;, <span class="hljs-type">int</span>&amp;)&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>或：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;, <span class="hljs-type">int</span>&amp;)</span></span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>意为“当实参为两个int类型时，不要使用Swap()模板来生成函数定义，而应使用专门为int类型显式地定义地具体函数”。</p><h4 id="（2）动态多态"><a href="#（2）动态多态" class="headerlink" title="（2）动态多态"></a>（2）动态多态</h4><p>动态多态主要通过继承重写基类的虚函数实现，在程序运行时根据基类的指针（或引用）指向的对象来确定自己具体调用哪一个类的虚函数。</p><h2 id="3-类的4个默认函数"><a href="#3-类的4个默认函数" class="headerlink" title="3. 类的4个默认函数"></a>3. 类的4个默认函数</h2><p>类的4个默认函数分别为构造函数、析构函数、拷贝函数和赋值函数。通常来讲，1个类包含多个构造函数（由1个或多个普通构造函数与1个拷贝构造函数组成）、1个赋值函数和1个析构函数。若不编写上述函数，C++编译器会自动为类产生4个缺省的函数。然而，使用默认的构造函数与析构函数，相当于放弃了自主“初始化”与“清除”机会。同时，默认的拷贝构造函数、赋值函数采用“位拷贝”而非“值拷贝”，类中含指针变量时将出错。</p><h4 id="（1）构造函数"><a href="#（1）构造函数" class="headerlink" title="（1）构造函数"></a>（1）构造函数</h4><p>构造函数是与类同名、无返回值的特殊成员函数，提供对成员变量初始化的方法。程序创建时将自动调用构造函数。</p><ul><li><p><strong>默认的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>() &#123;<br><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>默认构造函数无参，仅负责创建对象而不进行赋值操作。</p></li><li><p><strong>无参带赋值操作的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>() &#123;<br>name = <span class="hljs-string">&#x27;xiaoming&#x27;</span>;<br>        garde = <span class="hljs-number">90</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该函数将覆盖默认构造函数，它不仅创建对象还负责成员初始化。</p></li><li><p><strong>带参的带赋值操作的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> g) &#123;<br>name = n;<br>        garde = g;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该构造函数也将覆盖默认的构造函数。</p><p><strong>注意：</strong>一旦类中只包含带参的构造函数而不包含不带参的构造函数时，将无法创建不带参数的对象，程序将报错。</p><p><strong>解决办法：</strong>手动写一个默认构造函数，或给带参函数赋默认参数。</p></li></ul><p><strong>也可通过初始化表进行初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> g): <span class="hljs-built_in">name</span>(x), <span class="hljs-built_in">grade</span>(g) &#123;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（2）拷贝构造函数-amp-赋值函数"><a href="#（2）拷贝构造函数-amp-赋值函数" class="headerlink" title="（2）拷贝构造函数 &amp; 赋值函数"></a>（2）拷贝构造函数 &amp; 赋值函数</h4><p>默认的拷贝构造函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Student(<span class="hljs-params">const</span> Student&amp; <span class="hljs-params">stu</span>)</span><br></code></pre></td></tr></table></figure><p>默认的赋值函数：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Student<span class="hljs-meta">&amp; operater=(const Student&amp; stu)</span><br></code></pre></td></tr></table></figure><p>拷贝构造函数是在创建对象时调用，而赋值函数只能被已存在的对象调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;world&quot;</span>)</span></span>;<br>string c = a; <span class="hljs-comment">//调用了拷贝构造函数，也可写成stirng c(a);</span><br>c = b; <span class="hljs-comment">//调用了赋值函数 </span><br></code></pre></td></tr></table></figure><h4 id="（3）析构函数"><a href="#（3）析构函数" class="headerlink" title="（3）析构函数"></a>（3）析构函数</h4><p>也是无参无返回类型的特殊成员函数，但它不能随意调用，没有重载，只有在类对象的生命期结束时，由系统自动调用，用来在系统释放对象前做一些清理工作。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/2022/01/28/MyFirstBlog/"/>
    <url>/2022/01/28/MyFirstBlog/</url>
    
    <content type="html"><![CDATA[<p>深夜被一些诡异的报错反复折磨，气到重装Ubuntu。漫长的安装等待中想到，要不边等边把个人博客给建了吧，于是一通操作两天后有了现在的这篇blog。</p><p>鉴于本人的菜鸡水平应该也没办法分享出什么技术，这个博客大概就是给自己的各种笔记啥的找个归属地。</p><p>所以本人的寒假又多了点乐子：把博客建得像模像样一点（误</p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
