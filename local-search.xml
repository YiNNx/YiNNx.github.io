<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Note for Python 02</title>
    <link href="/2022/02/16/PygameNote/"/>
    <url>/2022/02/16/PygameNote/</url>
    
    <content type="html"><![CDATA[<h1 id="Pygame"><a href="#Pygame" class="headerlink" title="Pygame"></a>Pygame</h1><blockquote><p><a href="https://www.pygame.org/docs/">官方文档 </a></p></blockquote><h3 id="1-模块常用内容"><a href="#1-模块常用内容" class="headerlink" title="1.模块常用内容"></a>1.模块常用内容</h3><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><ul><li><strong>init()：</strong> 初始化程序</li><li><strong>quit()：</strong> 卸载所有模块</li></ul><h4 id="子模块-amp-函数："><a href="#子模块-amp-函数：" class="headerlink" title="子模块 &amp; 函数："></a>子模块 &amp; 函数：</h4><ul><li><strong>display模块</strong><ul><li><strong>set_caption()</strong> ：设置窗口标题</li><li><strong>set_mode()</strong> ：创建图形类型Surface对象</li><li><strong>set_icon()</strong> ：设置左上角的游戏图标，图标尺寸大小为 32*32。</li><li><strong>flip()</strong> ：更新屏幕内容</li></ul></li><li><strong>event模块</strong><ul><li><strong>get()</strong> ：获取事件</li></ul></li><li><strong>font模块</strong><ul><li><strong>Font()</strong> ：创建Font对象</li></ul></li><li><strong>time模块</strong><ul><li><strong>pygame.time.get_ticks()</strong> ：以毫秒为单位获取时间</li><li><strong>pygame.time.wait()</strong> ：使程序暂停一段时间</li><li><strong>pygame.time.set_timer()</strong> ：创建一个定时器，即每隔一段时间，去执行一些动作</li><li><strong>pygame.time.Clock()</strong> ：创建一个时钟对象来帮我们确定游戏要以多大的帧数运行</li></ul></li><li><strong>image模块</strong><ul><li><strong>load()</strong> ：将图像返回为一个Surface对象</li></ul></li></ul><h4 id="类-amp-方法："><a href="#类-amp-方法：" class="headerlink" title="类 &amp; 方法："></a>类 &amp; 方法：</h4><ul><li><p><strong>Surface类</strong></p><ul><li><strong>Surface(size&#x3D;(width,height),flags,depth)</strong> ：创建一个surface类</li><li><strong>fill()</strong> ：填充颜色</li><li><strong>set_alpha()</strong> ：设置整个图像的透明度</li><li><strong>blit()</strong> ：拼接Surface对象，第一个参数为一个Surface对象表内容，第二个参数为一个Rect对象表位置</li><li><strong>scroll()</strong> ：复制并移动 Surface 对象</li><li><strong>subsurface()</strong> ：根据父对象创建一个新的子 Surface 对象</li><li><strong>get_rect()</strong> ：获得自身表rect区域坐标的Rect对象</li></ul></li><li><p><strong>Font类</strong></p><ul><li><strong>render()</strong> ：创建文本类型Surface对象</li></ul></li><li><p><strong>Rect类</strong></p><ul><li><strong>Rect(left,top,width,height)</strong> ：创建一个Rect类，表示窗口上的一块矩形区域</li><li><strong>center</strong>：表显示中心坐标</li></ul></li><li><p><strong>Event类</strong></p><ul><li><strong>type</strong></li></ul></li></ul><h3 id="2-初始化程序"><a href="#2-初始化程序" class="headerlink" title="2. 初始化程序"></a>2. 初始化程序</h3><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python">pygame.init()<br></code></pre></td></tr></table></figure><p>它的作用是自动检测 Pygame 软件包是否正常可用，并检查电脑的硬件调用接口、基础功能是否存在问题，比如音频、光驱、声卡驱动等设备。同时，它会完成 <strong>Pygame 中所有模块的初始化操作</strong>，比如 display（显示模块）、font（字体模块）、mixer（声音控制模块）、cursors（光标控制模块）等。</p><h3 id="3-创建Surface对象"><a href="#3-创建Surface对象" class="headerlink" title="3. 创建Surface对象"></a>3. 创建Surface对象</h3><p><strong>创建一个 surface 对象：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">screen = pygame.display.set_mode((<span class="hljs-number">800</span>,<span class="hljs-number">600</span>))<br></code></pre></td></tr></table></figure><p><strong>设置背景颜色</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">screen</span>.fill((<span class="hljs-number">138</span>,<span class="hljs-number">151</span>,<span class="hljs-number">146</span>))<br></code></pre></td></tr></table></figure><p>screen 是一个 Surface 对象，它是游戏的主窗口，任何其他的 Surface 对象都需要附着于此。</p><p>创建包含文本的 Surface 对象，然后将它绘制在主屏幕上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建一个包含文字的Surface对象</span><br>text = f.render(<span class="hljs-string">&quot;Hello, world!&quot;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>))<br><span class="hljs-comment">#通过blit方法将其绘制在主屏幕上，textRect表示位置坐标</span><br>screen.blit(text,textRect)<br></code></pre></td></tr></table></figure><p><strong>创建一个图像的Surface对象</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">surface_image =pygame.image.load(<span class="hljs-string">&quot;图片路径&quot;</span>) <br></code></pre></td></tr></table></figure><h3 id="4-事件监听"><a href="#4-事件监听" class="headerlink" title="4. 事件监听"></a>4. 事件监听</h3><p>Pygame 提供了一个 event 模块，这个模块中包含了所有常用到游戏事件。如退出游戏：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 循环获取事件，监听事件状态，使用get()获取事件</span><br><span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br><span class="hljs-comment"># 判断事件类型，用户是否点了&quot;X&quot;关闭按钮(pygame.QUIT)</span><br><span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:   <br>pygame.quit()<br></code></pre></td></tr></table></figure><h3 id="5-游戏循环"><a href="#5-游戏循环" class="headerlink" title="5. 游戏循环"></a>5. 游戏循环</h3><p>如果想要达到“循环监听”目的，需要设置一个游戏循环（Game Loop）也称为游戏的主循环。一个最基本的只包含退出操作的主循环如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <br>    <span class="hljs-comment"># 循环获取事件，监听事件    </span><br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():        <br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:            <br>        <span class="hljs-comment"># 当用户关闭游戏窗口时执行以下操作            </span><br>            pygame.quit()                   <br>            sys.exit()    <br>    <span class="hljs-comment">#更新并绘制屏幕内容    </span><br>    pygame.display.flip() <br></code></pre></td></tr></table></figure><p>游戏主循环主要承担以下任务：</p><ul><li>处理游戏事件</li><li>更新游戏状态</li><li>把更新后的游戏状态绘制到屏幕上</li></ul><p>游戏画面和游戏操作状态会因为动画效果和玩家的操作而改变，因此需要以循环的方式实时地更新主屏幕（screen）的显示内容。把下列代码放入游戏主循环中即可实现实时更新和绘制屏幕内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#刷新界面显示</span><br>pygame.display.flip() <br></code></pre></td></tr></table></figure><p>除了上述方法外，Pygame 还提供了另一个方法：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">pygame.<span class="hljs-keyword">display</span>.up<span class="hljs-meta">date</span>() <br></code></pre></td></tr></table></figure><p>这两个方法的主要区别是：后者可以根据选定的区域来更新部分内容，而前者则是更新整个待显示的内容。如果后者没有提供区域位置参数时，其作用和 display.flip() 相同。</p><h2 id="display模块"><a href="#display模块" class="headerlink" title="display模块"></a>display模块</h2><h4 id="创建游戏主窗口："><a href="#创建游戏主窗口：" class="headerlink" title="创建游戏主窗口："></a>创建游戏主窗口：</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">screen = pygame.display.<span class="hljs-built_in">set_mode</span>(size=(),flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>Display模块中的<code>set_mode()</code>函数负责创建Surface对象，它返回一个Surface对象，同时接收两个参数用于设置窗口大小和样式：</p><ul><li><strong>size：</strong>元组参数，用来设置主窗口的大小</li><li><strong>flags：</strong>功能标志位，表示创建的主窗口样式，比如创建全屏窗口、无边框窗口等</li><li>在主窗口中，我们还可以添加各种小的 Surface 对象，这些对象以矩形的形式存在于主窗口中，它们共同组成了一个游戏程序。通过blit方法将一个 Surface 对象粘贴至主窗口上：</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">screen.blit(source, dest, <span class="hljs-built_in">area</span>=<span class="hljs-built_in">None</span>, special_flags = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="Surface类：创建图像"><a href="#Surface类：创建图像" class="headerlink" title="Surface类：创建图像"></a>Surface类：创建图像</h2><p>Pygame 针对文本、图像、颜色提供了不同模块来生成它们各自的 Surface 对象。</p><h4 id="Surface-函数"><a href="#Surface-函数" class="headerlink" title="Surface()函数"></a>Surface()函数</h4><p>是Pygame 中专门用来新建图像的，可以创建一个 Surface 对象，语法格式如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Surface=pygame.<span class="hljs-constructor">Surface(<span class="hljs-params">size</span>=(<span class="hljs-params">width</span>,<span class="hljs-params">height</span>)</span>,flags,depth)<br></code></pre></td></tr></table></figure><p>参数函数如下：</p><ul><li>size：表示 Surface 对象的矩形区域大小；</li><li>flags：功能标志位，有两个可选参数值 HWSURFACE 和 SPCALPHA。HWSURFACE 代表将创建的 Surface 对象存放于显存中， SPCALPHA表示让图像的每一个像素都包含一个 alpha 通道</li><li>depth：指定像素的颜色深度，默认为自适应模式，由 Pygame 自动调节。</li></ul><h2 id="image模块"><a href="#image模块" class="headerlink" title="image模块"></a>image模块</h2><p>除了使用 Surface 模块新建图像外，另外一种从外部加载图像的方法：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">pygame.<span class="hljs-built_in">image</span>.<span class="hljs-built_in">load</span>(<span class="hljs-string">&quot;图片路径&quot;</span>).<span class="hljs-built_in">convert</span>()  <br></code></pre></td></tr></table></figure><p>该方法返回一个 Surface 对象。convert(）用于转换被加载图片的像素格式，从而提升 Pygame 对图片的处理速度，该操作能够保证图像的像素格式与图片的显示格式是相同的。</p><h2 id="time模块：时间控制"><a href="#time模块：时间控制" class="headerlink" title="time模块：时间控制"></a>time模块：时间控制</h2><p>time 模块主要用于管理时间和帧数率（即 FPS）。</p><p><strong>Point：</strong>Pygame 中时间以毫秒为单位（1秒&#x3D;1000毫秒）。</p><h3 id="1-游戏暂停"><a href="#1-游戏暂停" class="headerlink" title="1) 游戏暂停"></a>1) 游戏暂停</h3><p>常用方法如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.time.get_ticks()</td><td>以毫秒为单位获取时间</td></tr><tr><td>pygame.time.wait()</td><td>使程序暂停一段时间</td></tr><tr><td>pygame.time.set_timer()</td><td>创建一个定时器，即每隔一段时间，去执行一些动作</td></tr><tr><td>pygame.time.Clock()</td><td>创建一个时钟对象来帮我们确定游戏要以多大的帧数运行</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br>pygame.init()<br>screen = pygame.display.set_mode((<span class="hljs-number">500</span>,<span class="hljs-number">500</span>))<br><span class="hljs-comment"># 获取以毫秒为单位的时间</span><br>t = pygame.time.get_ticks() <span class="hljs-comment">#该时间指的从pygame初始化后开始计算，到调用该函数为止</span><br>t1 =pygame.time.wait(<span class="hljs-number">3000</span>) <span class="hljs-comment">#暂停游戏3000毫秒</span><br><span class="hljs-built_in">print</span>(t1)<br><span class="hljs-comment">#暂停t1时间后，加载图片</span><br>image_surface = pygame.image.load(<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/c-net.png&quot;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            exit()<br>    screen.blit(image_surface,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>    pygame.display.update()<br></code></pre></td></tr></table></figure><h3 id="2-设置游戏FPS"><a href="#2-设置游戏FPS" class="headerlink" title="2) 设置游戏FPS"></a>2) 设置游戏FPS</h3><p>设置游戏的帧数率（FPS）可通过 Clock() 方法来实现：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.time.Clock.tick()</td><td>更新clock对象</td></tr><tr><td>pygame.time.Clock.get_time()</td><td>获取上一个tick中的时间</td></tr><tr><td>pygame.time.Clock.get_fps()</td><td>计算clock对象的帧率</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建时钟对象（控制游戏的FPS）</span><br>clock = pygame.time.Clock()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#通过时钟对象，指定循环频率，每秒循环60次</span><br>    clock.tick(<span class="hljs-number">60</span>)<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            exit()<br>    screen.blit(image_surface,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>    pygame.display.update()<br></code></pre></td></tr></table></figure><p>注意：FPS（游戏帧率）影响效果只有在动态图时才能显现出来，不过无论静态图还是动态图，它们的使用规则都是一样的。</p><h2 id="Rect类：区域位置"><a href="#Rect类：区域位置" class="headerlink" title="Rect类：区域位置"></a>Rect类：区域位置</h2><p>Rect（rectangle）指的是矩形，使用 Rect() 方法来创建一个指定位置，大小的矩形区域如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">rect =pygame.<span class="hljs-constructor">Rect(<span class="hljs-params">left</span>,<span class="hljs-params">top</span>,<span class="hljs-params">width</span>,<span class="hljs-params">height</span>)</span> <br></code></pre></td></tr></table></figure><p>Rect 表示的区域必须位于一个 Surface 对象之上，比如游戏的主窗口。</p><p><strong>Point</strong>：在 Pygame 中以游戏主窗口的左上角为坐标原点。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">image_surface = pygame.image.load(<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/c-net.png&quot;</span>)<br><br>rect1 = pygame.Rect(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)<br><span class="hljs-comment"># 在原图的基础上创建一个新的子图（surface对象）</span><br>image_child= image_surface.subsurface(rect1)<br><br>rect2 = image_child.get_rect()<br><span class="hljs-comment">#输出的矩形大小为 100*100</span><br><span class="hljs-built_in">print</span>(rect2)<br><br>screen.blit(image_child,rect1)<br></code></pre></td></tr></table></figure><p>可通过属性对来设置更改矩形区域的大小：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">rect1.left</span> = <span class="hljs-number">30</span> <br><span class="hljs-attr">rect1.center</span> = (<span class="hljs-number">70</span>,<span class="hljs-number">70</span>)<br></code></pre></td></tr></table></figure><p>除了通过 Rect 对象来构造一个矩形区域之外，还可以使用<code>rect</code>属性来构建一个矩形区域。在 Pygame 中有许多函数都提供了<code>rect</code>属性，比如有下列函数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">surface</span>.fill((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>),rect=(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">50</span>))<br></code></pre></td></tr></table></figure><p>上述代码会在 surface 对象的区域内选定一个 rect 区域，并将该区域填充为蓝色（RGB(0,0,255)）。</p><h2 id="event模块"><a href="#event模块" class="headerlink" title="event模块"></a>event模块</h2><p>事件（Event）是构建整个游戏程序的核心，比如鼠标点击、键盘敲击、游戏窗口移动、调整窗口大小、触发特定的情节、退出游戏等。<strong>Pygame 定义了一个专门用来处理事件的结构，即事件队列</strong>。该结构遵循队列“先进先出”的基本原则，通过事件队列，我们可以有序的、逐一的处理用户的操作。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#等待事件发生</span><br>    event = pygame.event.wait()<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>        exit()<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEBUTTONDOWN:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标按下&#x27;</span>,event.pos)<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEBUTTONUP:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标弹起&#x27;</span>)<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEMOTION:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标移动&#x27;</span>)<br>        <span class="hljs-comment"># 键盘事件</span><br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> ==pygame.KEYDOWN:<br>        <span class="hljs-comment"># 打印按键的英文字符</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘按下&#x27;</span>,<span class="hljs-built_in">chr</span>(event.key))<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.KEYUP:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘弹起&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="处理键盘事件"><a href="#处理键盘事件" class="headerlink" title="处理键盘事件"></a>处理键盘事件</h3><p>键盘事件提供了一个 key 属性，通过该属性可以获取键盘的按键。Pygame 将键盘上的字母键、数字键、组合键等按键以常量的方式进行了定义。示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">while</span> True:<br>    site = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.type == pygame.QUIT:<br>            sys.<span class="hljs-keyword">exit</span>()<br>        <span class="hljs-comment"># 图像移动 KEYDOWN 键盘按下事件</span><br>        <span class="hljs-comment"># 通过 key 属性对应按键</span><br>        <span class="hljs-keyword">if</span> event.type == pygame.KEYDOWN:<br>            <span class="hljs-keyword">if</span> event.key == pygame.K_UP:<br>                site[<span class="hljs-number">1</span>] -= <span class="hljs-number">8</span><br>            <span class="hljs-keyword">if</span> event.key == pygame.K_DOWN:<br>                site[<span class="hljs-number">1</span>] += <span class="hljs-number">8</span><br>            <span class="hljs-keyword">if</span> event.key == pygame.K_LEFT:<br>                site[<span class="hljs-number">0</span>] -= <span class="hljs-number">8</span><br>            <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>                site[<span class="hljs-number">0</span>] += <span class="hljs-number">8</span><br>    <span class="hljs-comment"># 移动图像</span><br>    position = position.move(site)<br>    <span class="hljs-comment"># 填充背景</span><br>    screen.fill(bg)<br>    <span class="hljs-comment"># 放置图片</span><br>    screen.blit(img, position)<br>    <span class="hljs-comment"># 更新显示界面</span><br>    pygame.display.flip()<br></code></pre></td></tr></table></figure><h3 id="处理鼠标事件"><a href="#处理鼠标事件" class="headerlink" title="处理鼠标事件"></a>处理鼠标事件</h3><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">while</span> True:<br>    <span class="hljs-comment">#等待事件发生</span><br>    event = pygame.event.wait()<br>    <span class="hljs-keyword">if</span> event.type == pygame.QUIT:<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;成功退出&quot;</span>)<br>    <span class="hljs-keyword">if</span> event.type == pygame.MOUSEBUTTONDOWN:<br>        <span class="hljs-comment"># pos 获取鼠标当前位置</span><br>        print(<span class="hljs-string">&#x27;鼠标按下&#x27;</span>,event.pos)<br>        mx,my = event.pos<br>        <span class="hljs-comment"># 调用 pygame.draw 模块画圆</span><br>        pygame.draw.circle(screen,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),(mx,my),<span class="hljs-number">50</span>)<br>        <span class="hljs-comment"># 处理完，更新显示</span><br>        pygame.display.update()<br>    <span class="hljs-keyword">if</span> event.type == pygame.MOUSEBUTTONUP:<br>        print(<span class="hljs-string">&#x27;鼠标弹起&#x27;</span>)<br>        pass<br>    <span class="hljs-keyword">if</span> event.type == pygame.MOUSEMOTION:<br>        print(<span class="hljs-string">&#x27;鼠标移动&#x27;</span>)<br>        mx, my = event.pos<br>        <span class="hljs-comment"># 随机生成 RGB 颜色值</span><br>        r = randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>        g = randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>        b = randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>        pygame.draw.circle(screen, (r,g,b,),(mx, my), <span class="hljs-number">50</span>)<br>        <span class="hljs-comment"># 处理完，更新显示</span><br>        pygame.display.update()<br></code></pre></td></tr></table></figure><h2 id="font模块：文本和字体"><a href="#font模块：文本和字体" class="headerlink" title="font模块：文本和字体"></a>font模块：文本和字体</h2><p><code>pygame.font</code>模块常用方法如下：</p><p>Font 模块提供了两种创建Font类对象的方法，分别是：</p><ul><li>SysFont（从系统中加载字体文件创建字体对象）</li><li>Font（通过文件路径创建字体对象）</li></ul><h4 id="1-font-SysFont"><a href="#1-font-SysFont" class="headerlink" title="1) font.SysFont()"></a>1) font.SysFont()</h4><p>直接从系统中加载字体使用如下方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pygame.font.SysFont(name, size, <span class="hljs-attribute">bold</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">italic</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li><p>name：列表参数值，表示要从系统中加载的字体名称，它会按照列表中的元素顺序依次搜索，如果系统中没有列表中的字体，将使用 Pygame 默认的字体。</p></li><li><p>size：表示字体的大小；</p></li><li><p>bold：字体是否加粗；</p></li><li><p>italic：字体是否为斜体。</p></li></ul><h4 id="2-font-Font"><a href="#2-font-Font" class="headerlink" title="2) font.Font()"></a>2) font.Font()</h4><p>Font()可从外部加载字体文件来绘制文本：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">my_font = pygame.font.<span class="hljs-constructor">Font(<span class="hljs-params">filename</span>, <span class="hljs-params">size</span>)</span> <br></code></pre></td></tr></table></figure><ul><li>filename：字符串格式，表示字体文件的所在路径；</li><li>size：设置字体的大小。</li></ul><h2 id="sprite模块：精灵和碰撞检测"><a href="#sprite模块：精灵和碰撞检测" class="headerlink" title="sprite模块：精灵和碰撞检测"></a>sprite模块：精灵和碰撞检测</h2><p>在一个游戏程序中，精灵（ Sprite）本质指的是一张张小尺寸的图片，比如游戏中的各种道具、人物、场景装饰等，它们都可以看做成一张张小的“精灵”图。除此之外，人物的移动也可以看做是一系列小精灵图构成的序列（按帧组成的序列）。</p><p>如果将逐帧分解后的动作，按照一定的频率播放，那么就形成了动画精灵。</p><p>精灵有个特点就是允许精灵之间进行交互，也称之为碰撞，而碰撞检测，指的就是检测两个精灵之间是否发生了碰撞。比如在贪吃蛇游戏中蛇的头部是否与食物发生了碰撞，或者飞机大战游戏中子弹是否击中了外星人等等。当检测到碰撞发生后，接下来会触发某些事件，比如子弹击中外星人，外星人就会消失，玩家的得分也会随之增加，并且在游戏屏幕上又会出现一个外星人。</p><p>Pygame 专门提供了一个处理精灵的模块，也就是 sprite模块。<strong>通常使用该模块的基类 Sprite 来创建一个子类，从而达到处理精灵的目的</strong> ，该子类提供了操作精灵的常用属性和方法。</p><p>当游戏中有大量的精灵时，操作它们将变得复杂，此时通过构建精灵容器（group 类）也就是精灵组来统一管理这些精灵。构建方法如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 创建精灵组</span><br><span class="hljs-keyword">group</span> <span class="hljs-title">= pygame</span>.sprite.Group()<br><span class="hljs-comment"># 向组内添加一个精灵</span><br>group.add(sprite_one)<br></code></pre></td></tr></table></figure><p>于此同时<code>pygame.sprite</code>模块也提供了多种检测精灵是否碰撞的方法。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span>(pygame.sprite.Sprite):<br>    <span class="hljs-comment">#定义构造函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,filename,location</span>):<br>        <span class="hljs-comment"># 调父类来初始化子类</span><br>        pygame.sprite.Sprite.__init__(self)<br>        <span class="hljs-comment"># 加载图片</span><br>        self.image = pygame.image.load(filename)<br>        <span class="hljs-comment"># 获取图片rect区域</span><br>        self.rect = self.image.get_rect()<br>        <span class="hljs-comment"># 设置位置</span><br>        self.rect.topleft=location<br><span class="hljs-comment"># 初始化pygame</span><br>pygame.init()<br>screen = pygame.display.set_mode((<span class="hljs-number">500</span>,<span class="hljs-number">400</span>))<br><br><span class="hljs-comment"># 填充为白色屏幕</span><br>screen.fill((<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>))<br>filename =<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/snake.png&quot;</span><br>location =(<span class="hljs-number">100</span>,<span class="hljs-number">150</span>)<br>snake1 = Snake(filename,location)<br><span class="hljs-comment"># 碰撞检测,必须有两个精灵，因此再创建一个精灵，并使用location来控制第二个精灵的位置</span><br>location_2 = (<span class="hljs-number">100</span>,<span class="hljs-number">80</span>)<br>snake2 = Snake(<span class="hljs-string">&#x27;C:/Users/Administrator/Desktop/logo.png&#x27;</span>,location_2)<br><span class="hljs-comment"># 调用 collide_rect()进行矩形区域检测，返回一个布尔值，碰撞返回True，否则返回False</span><br>crash_result = pygame.sprite.collide_rect(snake1,snake2)<br><span class="hljs-keyword">if</span> crash_result:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;精灵碰撞了!&quot;</span>)<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;精灵没碰撞&#x27;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            pygame.quit()<br>            exit()<br>    <span class="hljs-comment"># 绘制精灵到屏幕上</span><br>    screen.blit(snake1.image,snake1.rect)<br>    screen.blit(snake2.image,snake2.rect)<br>    <span class="hljs-comment"># 刷新显示屏幕</span><br>    pygame.display.update()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note for Python 01</title>
    <link href="/2022/02/10/PythonNote/"/>
    <url>/2022/02/10/PythonNote/</url>
    
    <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h3 id="动态语言-amp-静态语言："><a href="#动态语言-amp-静态语言：" class="headerlink" title="动态语言 &amp; 静态语言："></a>动态语言 &amp; 静态语言：</h3><ul><li><p><strong>动态语言：</strong>变量本身类型不固定。使用变量无需声明，但使用前必须赋值，赋值后变量才被创建。</p><p><strong>e.g. Python、Ruby、JavaScript</strong></p></li><li><p><strong>静态语言：</strong>变量类型固定。在定义变量时必须指定变量类型，赋值时变量与对象的类型必须相匹配or进行转化。</p><p><strong>e.g. Java、C、C++</strong></p></li></ul><blockquote><p>动态语言和静态语言很大的不同在于：函数和类的定义不是编译时定义的，而是运行时动态创建的。</p></blockquote><h3 id="引用赋值："><a href="#引用赋值：" class="headerlink" title="引用赋值："></a>引用赋值：</h3><p>像Python、JS这类动态语言，基本上都是使用引用赋值。在引用赋值中，变量名和真实值分开保存。变量名保存的是真实值的一个指针，对变量赋值时，也是将这个指针赋给新变量，原来的“引用”则断开了。</p><h3 id="Python中的不可变类型-amp-可变类型："><a href="#Python中的不可变类型-amp-可变类型：" class="headerlink" title="Python中的不可变类型 &amp; 可变类型："></a>Python中的不可变类型 &amp; 可变类型：</h3><ul><li><p><strong>不可变类型： Number、String、Tuple</strong></p><p>当变量为不可变类型时，无法在内存中直接修改这个变量（如：100、’hello‘）。如果尝试对不可变类型进行修改，就会断开原始的引用，重新指向新的对象。</p></li><li><p><strong>可变类型：List、Dictionary、Set</strong></p><p>可以在内存中进行修改，修改可变类型的值不会断开原始引用。</p></li></ul><h3 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h3><p>主动发起TCP链接，接收服务器返回数据，实现一次完整的网络通信。</p><p>以获取新浪首页HTML文件为例：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#tcp基本连接新浪首页获取并打印http头</span><br><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> ssl<br><br>s = ssl.wrap_socket(socket.socket())<br><br><span class="hljs-comment">#建立连接</span><br>s.connect((<span class="hljs-string">&#x27;www.sina.com.cn&#x27;</span>, <span class="hljs-number">443</span>))<br><br>s.send(<span class="hljs-string">b&quot;GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n&quot;</span>)<br><br><span class="hljs-comment">#接受数据</span><br>buf = []<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    d = s.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-keyword">if</span> d:<br>        buf.append(d)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br>data = <span class="hljs-string">b&quot;&quot;</span>.join(buf)<br><br><span class="hljs-comment">#关闭tcp连接</span><br>s.close()<br><br>data = data.split(<span class="hljs-string">b&#x27;\r\n\r\n&#x27;</span>,<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#打印请求头把流数据进行解码</span><br><span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span>].decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-comment">#写进文件html，存入本地文件夹</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:/SE/CODE/Python/sina.html&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(data[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iFleaBooks</title>
    <link href="/2022/02/06/iFleaBooks/"/>
    <url>/2022/02/06/iFleaBooks/</url>
    
    <content type="html"><![CDATA[<h1 id="iFleaBooks"><a href="#iFleaBooks" class="headerlink" title="iFleaBooks"></a>iFleaBooks</h1><p>Linux环境下的二手书交易系统</p><p>是一个C++练手项目，实现了较完整的交易系统前后台功能，包括用户注册、登录、浏览商品、发布商品、修改信息，管理员进行后台数据管理，本地数据载入与更新等，并基于Linux命令行进行交互。</p><p><strong>GitHub链接：</strong><a href="https://github.com/yinn-x/iFleaBooks">https://github.com/yinn-x/iFleaBooks</a></p><hr><h3 id="开发环境："><a href="#开发环境：" class="headerlink" title="开发环境："></a><strong>开发环境：</strong></h3><p>Ubuntu &amp; VS Code</p><h3 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a><strong>实现功能：</strong></h3><p><strong>User：</strong></p><ul><li>注册 &amp; 登录 &amp; 注销；</li><li>浏览书库 &#x2F; 搜索书籍 &amp; 查看书的详细信息；</li><li>购买二手书 &amp; 查看已购订单；</li><li>发布二手书 &amp; 修改详细信息；</li><li>下架自己的发布 &amp; 查看卖出订单；</li><li>个人信息管理 &amp; 钱包充值。</li></ul><p><strong>Admin：</strong></p><ul><li>查看 &#x2F; 检索所有书籍 &amp; 下架书籍；</li><li>查看和管理所有订单；</li><li>查看和管理所有用户信息。</li></ul><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a><strong>效果</strong>：</h3><p>登录界面 &amp; 注册 ：</p>  <img src="/img/iFleaBooks/11.png" style="zoom:50%;" /><p>​          </p><p>浏览界面：</p> <img src="/img/iFleaBooks/22.png" style="zoom:50%;" /><p>​           </p><p>买书界面：</p>  <img src="/img/iFleaBooks/2.png" style="zoom:50%;" /><p>​       </p><p>钱包充值：</p>  <img src="/img/iFleaBooks/3.png" style="zoom:50%;" /><p>​     </p><p>管理员界面：</p><img src="/img/iFleaBooks/4.png" style="zoom:50%;" /><p>​    </p><p>还有一堆界面懒得截了（雾</p>]]></content>
    
    
    <categories>
      
      <category>Projects</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note of C++ Primer</title>
    <link href="/2022/02/02/Note%20of%20C++%20Primer/"/>
    <url>/2022/02/02/Note%20of%20C++%20Primer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-从-C-到-C"><a href="#1-从-C-到-C" class="headerlink" title="1. 从 C 到 C++"></a>1. 从 C 到 C++</h1><p>一些 C++ 的新特性：</p><p><strong>多态：</strong></p><ul><li><p>静态多态：</p><p>（1）重载（函数重载 &amp; 运算符重载） </p><p>（2）泛型（函数模板 &amp; 类模板）</p></li><li><p>动态多态：虚函数</p></li></ul><p><strong>类：</strong></p><ul><li><p>继承（基类 &amp; 子类）</p></li><li><p>封装 （类访问修饰符 &amp; 友元）</p></li><li><p>其他细节：（1）类的默认函数</p><p>​                   （2）运算符重载</p><p>​                   （3）this 指针</p></li></ul><p><strong>其他：</strong></p><ul><li><p>引用变量</p></li><li><p>范围 for 语句</p></li><li><p>迭代器</p></li><li><p>内联函数</p></li><li><p>new &amp; delete</p></li><li><p>流式文件读写</p></li><li><p>函数的默认参数</p></li></ul><h2 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h2><h4 id="（1）泛型编程"><a href="#（1）泛型编程" class="headerlink" title="（1）泛型编程"></a>（1）泛型编程</h4><p>泛型编程在 C++ 中主要通过模板函数和模板类实现。</p><p>函数模板的性质：</p><ol><li>函数模板不是真正的函数，只是编译时生成具体函数的一个”模子”。</li><li>函数模板不是编译一份满足多重需要，而是为每一种替换它的函数编译生成一份新函数。</li></ol><p>函数模板的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span>&#123;<br>T t = a;<br>a = b, b = t;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>template用于声明开始泛型编程，typyname用于声明泛指类型。</p></li><li><p>自动类型推导调用:</p><p><code> Swap(a, b);</code> </p><p>该调用属于隐式实例化。</p></li><li><p>具体类型显式调用：</p><p><code>Swap&lt;int&gt;(a, b);</code></p><p>该调用属于显式实例化。</p></li></ul><p>显式具体化：</p><p>一种模板定义，实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>&amp;, <span class="hljs-type">int</span>&amp;)&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>或：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;, <span class="hljs-type">int</span>&amp;)</span></span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>意为“当实参为两个int类型时，不要使用Swap()模板来生成函数定义，而应使用专门为int类型显式地定义地具体函数”。</p><h4 id="（2）动态多态"><a href="#（2）动态多态" class="headerlink" title="（2）动态多态"></a>（2）动态多态</h4><p>动态多态主要通过继承重写基类的虚函数实现，在程序运行时根据基类的指针（或引用）指向的对象来确定自己具体调用哪一个类的虚函数。</p><h2 id="3-类的4个默认函数"><a href="#3-类的4个默认函数" class="headerlink" title="3. 类的4个默认函数"></a>3. 类的4个默认函数</h2><p>类的4个默认函数分别为构造函数、析构函数、拷贝函数和赋值函数。通常来讲，1个类包含多个构造函数（由1个或多个普通构造函数与1个拷贝构造函数组成）、1个赋值函数和1个析构函数。若不编写上述函数，C++编译器会自动为类产生4个缺省的函数。然而，使用默认的构造函数与析构函数，相当于放弃了自主“初始化”与“清除”机会。同时，默认的拷贝构造函数、赋值函数采用“位拷贝”而非“值拷贝”，类中含指针变量时将出错。</p><h4 id="（1）构造函数"><a href="#（1）构造函数" class="headerlink" title="（1）构造函数"></a>（1）构造函数</h4><p>构造函数是与类同名、无返回值的特殊成员函数，提供对成员变量初始化的方法。程序创建时将自动调用构造函数。</p><ul><li><p><strong>默认的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>() &#123;<br><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>默认构造函数无参，仅负责创建对象而不进行赋值操作。</p></li><li><p><strong>无参带赋值操作的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>() &#123;<br>name = <span class="hljs-string">&#x27;xiaoming&#x27;</span>;<br>        garde = <span class="hljs-number">90</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该函数将覆盖默认构造函数，它不仅创建对象还负责成员初始化。</p></li><li><p><strong>带参的带赋值操作的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> g) &#123;<br>name = n;<br>        garde = g;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该构造函数也将覆盖默认的构造函数。</p><p><strong>注意：</strong>一旦类中只包含带参的构造函数而不包含不带参的构造函数时，将无法创建不带参数的对象，程序将报错。</p><p><strong>解决办法：</strong>手动写一个默认构造函数，或给带参函数赋默认参数。</p></li></ul><p><strong>也可通过初始化表进行初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> g): <span class="hljs-built_in">name</span>(x), <span class="hljs-built_in">grade</span>(g) &#123;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（2）拷贝构造函数-amp-赋值函数"><a href="#（2）拷贝构造函数-amp-赋值函数" class="headerlink" title="（2）拷贝构造函数 &amp; 赋值函数"></a>（2）拷贝构造函数 &amp; 赋值函数</h4><p>默认的拷贝构造函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Student(<span class="hljs-params">const</span> Student&amp; <span class="hljs-params">stu</span>)</span><br></code></pre></td></tr></table></figure><p>默认的赋值函数：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Student<span class="hljs-meta">&amp; operater=(const Student&amp; stu)</span><br></code></pre></td></tr></table></figure><p>拷贝构造函数是在创建对象时调用，而赋值函数只能被已存在的对象调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;world&quot;</span>)</span></span>;<br>string c = a; <span class="hljs-comment">//调用了拷贝构造函数，也可写成stirng c(a);</span><br>c = b; <span class="hljs-comment">//调用了赋值函数 </span><br></code></pre></td></tr></table></figure><h4 id="（3）析构函数"><a href="#（3）析构函数" class="headerlink" title="（3）析构函数"></a>（3）析构函数</h4><p>也是无参无返回类型的特殊成员函数，但它不能随意调用，没有重载，只有在类对象的生命期结束时，由系统自动调用，用来在系统释放对象前做一些清理工作。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>🔝 About</title>
    <link href="/2022/02/01/About/"/>
    <url>/2022/02/01/About/</url>
    
    <content type="html"><![CDATA[<h1 id="About"><a href="#About" class="headerlink" title="About"></a>About</h1><p>这里是YiNN的个人博客！</p><p>本人目前HUST SE大一在读 在写程序这块还是个萌新</p><p>爱好是画点小画，虽然好像很久没画了</p><p>这是我的<a href="https://heeeeeeeeeha.lofter.com/">lofter账号</a></p><p>然后平时大概是比较喜欢看电影刷剧啥的</p><p>这是我的<a href="https://www.douban.com/people/185275812/">豆瓣</a></p><p>(没写完待续)</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/2022/01/28/MyFirstBlog/"/>
    <url>/2022/01/28/MyFirstBlog/</url>
    
    <content type="html"><![CDATA[<p>深夜被一些诡异的报错反复折磨，气到重装Ubuntu。漫长的安装等待中想到，要不边等边把个人博客给建了吧，于是一通操作两天后有了现在的这篇blog。</p><p>鉴于本人的菜鸡水平应该也没办法分享出什么技术，这个博客大概就是给自己的各种笔记啥的找个归属地。</p><p>所以本人的寒假又多了点乐子：把博客建得像模像样一点（误</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
