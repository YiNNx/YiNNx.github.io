<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GoMemo</title>
    <link href="/2022/03/26/GoMemo/"/>
    <url>/2022/03/26/GoMemo/</url>
    
    <content type="html"><![CDATA[<h1 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片slice</h1><p>切片是一个引用类型（指针）</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//对数组进行切片：</span><br>arr3 := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>sl := []<span class="hljs-type">int</span>(arr3[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]) <span class="hljs-comment">//[start:end]</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//从字符串生成字节切片：</span><br>b:= []<span class="hljs-type">byte</span>(str)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//使用 make() 函数来创建一个切片，同时创建相关数组：</span><br><span class="hljs-comment">//len是必须的，cap可为空</span><br>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>)<span class="hljs-comment">//[]type, len, cap</span><br></code></pre></td></tr></table></figure><ul><li>slice可索引，由 <code>len()</code> 获取长度。</li><li>数组的长度在运行时不可修改，切片的长度在运行时可修改</li></ul><h3 id="切片重组-reslicing"><a href="#切片重组-reslicing" class="headerlink" title="切片重组 reslicing"></a>切片重组 reslicing</h3><h4 id="append"><a href="#append" class="headerlink" title="append()"></a><code>append()</code></h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">func append(s[]<span class="hljs-built_in">T</span>, x ...<span class="hljs-built_in">T</span>) []<span class="hljs-built_in">T</span><br></code></pre></td></tr></table></figure><p>如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。</p><p>如果想将切片 y 追加到切片 x 后面，只要将第二个参数扩展成一个列表即可：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = append(x, y...)<br></code></pre></td></tr></table></figure><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a><code>copy()</code></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copy</span><span class="hljs-params">(dst, src []T)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>将类型为 T 的切片从源地址 src 拷贝到目标地址 dst，覆盖 dst 的相关元素，并且返回拷贝的元素个数。</p><p>1.不同类型的切片无法复制<br>2.如果s1的长度大于s2的长度，将s2中对应位置上的值替换s1中对应位置的值<br>3.如果s1的长度小于s2的长度，多余的将不做替换</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//声明map</span><br><span class="hljs-keyword">var</span> map1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//带初始化的声明</span><br>mapLit := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//使用make()创建map</span><br>mp := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float32</span>)<br></code></pre></td></tr></table></figure><p>key 可以是任意可以用 &#x3D;&#x3D; 或者 !&#x3D; 操作符比较的类型，比如 string、int、float。所以数组、切片和结构体不能作为 key；value 可以是任意类型的。</p><h3 id="用切片作为value"><a href="#用切片作为value" class="headerlink" title="用切片作为value"></a>用切片作为value</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">mp1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h3 id="测试key是否存在"><a href="#测试key是否存在" class="headerlink" title="测试key是否存在"></a>测试key是否存在</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">val1,</span> isPresent = map1[key1]<br></code></pre></td></tr></table></figure><p>如果 key1 存在于 map1，val1 就是 key1 对应的 value ，且 isPresent为true；如果 key1 不存在，val1 是一个空值，并 isPresent 为false。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//和 if 混合使用：</span><br><span class="hljs-keyword">if</span> _, ok := map1[key1]; ok &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">delete</span><span class="hljs-params">(map1, key1)</span></span><br></code></pre></td></tr></table></figure><h3 id="for-range-的配套用法"><a href="#for-range-的配套用法" class="headerlink" title="for-range 的配套用法"></a>for-range 的配套用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> map1 &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map-类型的切片"><a href="#map-类型的切片" class="headerlink" title="map 类型的切片"></a>map 类型的切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">items := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment">//切片items的每个元素都是map类型，且值为nil</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//通过索引初始化切片中的map元素</span><br><span class="hljs-keyword">for</span> i:= <span class="hljs-keyword">range</span> items &#123;<br>items[i] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>items[i][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-comment">//下面这种操作是错误的，无法初始化真正的map元素</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items2 &#123;<br>item = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// item is only a copy of the slice element.</span><br>item[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// This &#x27;item&#x27; will be lost on the next iteration.</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map的排序"><a href="#map的排序" class="headerlink" title="map的排序"></a>map的排序</h3><p>需要将 key（或者 value）拷贝到一个切片，再对切片排序（使用 sort 包，详见第 7.6.6 节），然后可以使用切片的 for-range 方法打印出所有的 key 和 value。</p><h1 id="结构struct"><a href="#结构struct" class="headerlink" title="结构struct"></a>结构struct</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> identifier <span class="hljs-keyword">struct</span> &#123;<br>    field1 type1<br>    field2 type2<br>    ...<br>&#125;<br><span class="hljs-comment">//一般在函数外声明</span><br></code></pre></td></tr></table></figure><h3 id="使用-new"><a href="#使用-new" class="headerlink" title="使用 new"></a><strong>使用 new</strong></h3><p>使用 <strong>new</strong> 函数给一个新的结构体变量分配内存，它返回指向已分配内存的指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//使用 new 函数给一个新的结构体变量分配内存</span><br><span class="hljs-comment">//t为指针，结构体字段为零值</span><br>stu1 := <span class="hljs-built_in">new</span>(student) <br><span class="hljs-comment">//相当于</span><br>stu2 := &amp;student&#123;name: <span class="hljs-string">&quot;a&quot;</span>, num: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-comment">//t是student类型</span><br>stu2 := student&#123;name: <span class="hljs-string">&quot;a&quot;</span>, num: <span class="hljs-number">1</span>&#125;<br><span class="hljs-comment">//打印：</span><br><span class="hljs-comment">//stu1: &amp;&#123;a 1&#125;</span><br><span class="hljs-comment">//stu2:  &#123;a 1&#125;</span><br></code></pre></td></tr></table></figure><h3 id="选择器（selector）"><a href="#选择器（selector）" class="headerlink" title="选择器（selector）"></a><strong>选择器（selector）</strong></h3><p>无论变量是一个结构体类型还是一个结构体类型指针，都使用同样的 <strong>选择器符（selector-notation）</strong> 来引用结构体的字段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">structname.fieldname<br></code></pre></td></tr></table></figure><h3 id="使用工厂方法创建结构体实例"><a href="#使用工厂方法创建结构体实例" class="headerlink" title="使用工厂方法创建结构体实例"></a>使用工厂方法创建结构体实例</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//结构体类型</span><br><span class="hljs-built_in">type</span> File <span class="hljs-keyword">struct</span> &#123;<br>    fd      int     <span class="hljs-comment">// 文件描述符</span><br>    name    <span class="hljs-keyword">string</span>  <span class="hljs-comment">// 文件名</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//对应的工厂方法（名字以 new 或 New 开头</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFile</span><span class="hljs-params">(fd <span class="hljs-type">int</span>, name <span class="hljs-type">string</span>)</span></span> *File &#123;<br>    <span class="hljs-keyword">if</span> fd &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;File&#123;fd, name&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>调用<br>f := NewFile(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;./test.txt&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="强制使用工厂方法"><a href="#强制使用工厂方法" class="headerlink" title="强制使用工厂方法"></a>强制使用工厂方法</h3><p>可以使类型自身对外部不可见，只有工厂方法对外可见，从而使类型变成私有的，就像在面向对象语言中那样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> matrix <span class="hljs-keyword">struct</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMatrix</span><span class="hljs-params">(params)</span></span> *matrix &#123;<br>    m := <span class="hljs-built_in">new</span>(matrix) <span class="hljs-comment">// 初始化 m</span><br>    <span class="hljs-keyword">return</span> m<br>&#125;<br></code></pre></td></tr></table></figure><p>在其他包里使用工厂方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;matrix&quot;</span><br>...<br>wrong := <span class="hljs-built_in">new</span>(matrix.matrix)     <span class="hljs-comment">// 编译失败（matrix 是私有的）</span><br>right := matrix.NewMatrix(...)  <span class="hljs-comment">// 实例化 matrix 的唯一方式</span><br></code></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量</p><p>接收者类型可以是（几乎）任何类型（除了接口</p><p>类型和作用在它上面定义的方法必须在同一个包里定义</p><p>定义方法的一般格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(recv receiver_type)</span></span> methodName(parameter_list) (return_value_list) &#123; ... &#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;<br>name  <span class="hljs-type">string</span><br>score <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStudent</span><span class="hljs-params">(name <span class="hljs-type">string</span>, score <span class="hljs-type">int</span>)</span></span> *student &#123;<br><span class="hljs-keyword">return</span> &amp;student&#123;name, score&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu student)</span></span> PrintStu() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;name:%v\nscore:%v&quot;</span>, stu.name, stu.score)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stu := NewStudent(<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-number">99</span>)<br>stu.PrintStu()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">type B struct &#123;<br>thing int<br>&#125;<br><br>func (<span class="hljs-selector-tag">b</span> *B) <span class="hljs-built_in">change</span>() &#123; <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.thing</span> = <span class="hljs-number">1</span> &#125;<br><br>func (<span class="hljs-selector-tag">b</span> B) <span class="hljs-built_in">write</span>() string &#123; return fmt<span class="hljs-selector-class">.Sprint</span>(b) &#125;<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">var</span> b1 B <span class="hljs-comment">// b1 是值</span><br>b1<span class="hljs-selector-class">.change</span>()<br>fmt<span class="hljs-selector-class">.Println</span>(b1<span class="hljs-selector-class">.write</span>())<br><br>b2 := <span class="hljs-built_in">new</span>(B) <span class="hljs-comment">// b2 是指针</span><br>b2<span class="hljs-selector-class">.change</span>()<br>fmt<span class="hljs-selector-class">.Println</span>(b2<span class="hljs-selector-class">.write</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过 getter 和 setter 方法实现包的封装特性。命名：对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名</p><h3 id="内嵌类型的方法和继承"><a href="#内嵌类型的方法和继承" class="headerlink" title="内嵌类型的方法和继承"></a>内嵌类型的方法和继承</h3><p>当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 <strong>继承</strong> 了这些方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>x, y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(p.x*p.x + p.y*p.y)<br>&#125;<br><br><span class="hljs-keyword">type</span> NamedPoint <span class="hljs-keyword">struct</span> &#123;<br>Point<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := &amp;NamedPoint&#123;Point&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, <span class="hljs-string">&quot;Pythagoras&quot;</span>&#125;<br>fmt.Println(n.Abs()) <span class="hljs-comment">// 打印 5</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="for-range结构"><a href="#for-range结构" class="headerlink" title="for-range结构"></a>for-range结构</h1><p>迭代string、数组、map等</p><p><strong>POINT：产生的只是值的一个拷贝，不能用来修改原对象的值。</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//pos为索引，char为内容（可以使用空白标识符丢弃</span><br><span class="hljs-type">str</span>:=<span class="hljs-string">&quot;hello,world!&quot;</span><br><span class="hljs-keyword">for</span> <span class="hljs-title class_">pos</span>, <span class="hljs-type">char</span> := range <span class="hljs-type">str</span> &#123;<br>fmt.<span class="hljs-title function_ invoke__">Printf</span>(<span class="hljs-string">&quot;Character on position %d is: %c \n&quot;</span>, pos, <span class="hljs-type">char</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="new-和-make-的区别"><a href="#new-和-make-的区别" class="headerlink" title="new() 和 make() 的区别"></a>new() 和 make() 的区别</h1><ul><li><p>new(T) </p><p> 用来分配内存，它的第一个参数是一个类型，不是一个值，它的返回值是一个指向新分配类型零值的指针</p></li><li><p>make(T) </p><p>内建函数 make 用来为 slice，map 或 chan 类型分配内存和初始化一个对象</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>Go</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Record</title>
    <link href="/2022/03/19/Bingyan/"/>
    <url>/2022/03/19/Bingyan/</url>
    
    <content type="html"><![CDATA[<blockquote><p>冰岩程序组2022春招 - 实习记录</p></blockquote><p>现在一整个人都处于很恍惚的状态</p>  <img src="/img/iFleaBooks/00.png" style="zoom:33%;" /><p>这周实习的收获太大了（虽然翘掉了两次微积分，但是管它呢</p><p>一开始连API应该长啥样都不知道，疯狂查各种实现方法，到最终完整写出来四个阶段，包括OAuth2.0的Server端和Client端。我居然真的做到了</p><p>写阶段二和阶段四确实是很痛苦的过程，感觉压根实现不出来，只能硬着头皮写，一个接一个地排查bug。幸运地还是迎来了漫漫长夜后的曙光。</p><p>这周无论是学到的东西还是做出来的东西，我都非常非常满意了。</p><hr><h1 id="CodingLog"><a href="#CodingLog" class="headerlink" title="CodingLog"></a>CodingLog</h1><h4 id="day-0-3-11"><a href="#day-0-3-11" class="headerlink" title="day 0___3.11"></a>day 0___3.11</h4><ul><li>确定选题OAuth2.0</li><li>建仓库 &amp; 思考下框架 &amp; 搞定git</li></ul><h4 id="day-1-3-12"><a href="#day-1-3-12" class="headerlink" title="day 1___3.12"></a>day 1___3.12</h4><blockquote><ul><li><p><input checked="" disabled="" type="checkbox"> <del>加入Bangumi并被安利双城之战</del></p></li><li><p><input checked="" disabled="" type="checkbox"> 学习Flask框架的使用</p><p><a href="https://dormousehole.readthedocs.io/en/1.1.2/quickstart.html">Flask中文文档</a></p><p><a href="https://segmentfault.com/a/1190000008404692">使用 Flask 开发 Web 应用（一）</a></p></li><li><p><input checked="" disabled="" type="checkbox"> 学习如何实现API</p></li><li><p><input disabled="" type="checkbox"> 系统学一下MySQL</p><p><a href="https://www.liaoxuefeng.com/wiki/1177760294764384">廖雪峰的官方网站</a></p></li></ul></blockquote><p>今天大部分的时间都花在了学Flask和API开发上面。之前从来没接触过API这个概念，也从没仔细思考过前后端应该通过什么样的方式分离。因此尝试了解API之后感觉打开了新世界的大门。但上手写时还是毫无头绪。之前写的iFleaBooks那个小项目里虽然也涉及用户的注册登录什么的，但都运行在本地命令行，逻辑非常之简单，控制输入输出就行了。而API中使用web请求和响应实现数据传输与处理，如何通过Flask实现这一过程还是感觉有点没完全掌握。</p><h4 id="day-2-3-13"><a href="#day-2-3-13" class="headerlink" title="day 2___3.13"></a>day 2___3.13</h4><blockquote><ul><li><input checked="" disabled="" type="checkbox"> 继续学Flask，把官方文档看完</li><li><input checked="" disabled="" type="checkbox"> 看完MySQL</li><li><input disabled="" type="checkbox"> 完成SQLAlchemy部分</li><li><input checked="" disabled="" type="checkbox"> 完成注册登录的错误输入处理</li><li><input disabled="" type="checkbox"> 琢磨一下邮箱验证</li></ul></blockquote><p>学了一上午数据库，尝试使用Python进行数据库操作的过程也还算顺利，也没有出现什么令人崩溃的bug。</p><p>继续进行SQLALchemy的操作。</p><h4 id="day-3-3-14"><a href="#day-3-3-14" class="headerlink" title="day 3___3.14"></a>day 3___3.14</h4><blockquote><ul><li><p><input checked="" disabled="" type="checkbox"> SQLAlchemy完成</p></li><li><p><input checked="" disabled="" type="checkbox"> 了解 <a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">OAuth2.0</a> 机制 &amp; 具体过程</p></li></ul></blockquote><p>被bug按在地上反复摩擦的一天…..上午总算是把阶段一粗糙地完成了。为什么感觉起来很简单但写起来还是超难。进度很显然太慢了。开始研究OAuth2.0。</p><p>不过值得一提的是实现了科学上网！在StackOverflow上查到了好几个bug的解决方法，以及google到了code和token的原理，真的很好用了。</p><h4 id="day-4-3-15"><a href="#day-4-3-15" class="headerlink" title="day 4__3.15"></a>day 4__3.15</h4><blockquote><ul><li><input checked="" disabled="" type="checkbox"> OAuth2.0 第三⽅⽹站注册</li><li><input checked="" disabled="" type="checkbox"> OAuth2.0 处理 Client ID 和 回调链接，redirect并返回 code </li><li><input checked="" disabled="" type="checkbox"> OAuth2.0 处理 Client ID 、 Client secrets 和 code，向第三⽅⽹站提供对应⽤⼾的 token</li></ul></blockquote><p>在逻辑上完成了OAuth2.0第二阶段部分。</p><h4 id="day-5-3-16"><a href="#day-5-3-16" class="headerlink" title="day 5__3.16"></a>day 5__3.16</h4><blockquote><ul><li><input checked="" disabled="" type="checkbox"> OAuth2.0 调试</li><li><input checked="" disabled="" type="checkbox"> 番剧查看和收藏功能</li><li><input disabled="" type="checkbox"> 搜索收藏的番剧</li></ul></blockquote><p>有一种熬过黑暗迎来黎明的感觉。OAuth2.0实在太难写了，昨天写得整个人丧心病狂丧失希望，但还是坚持捋顺逻辑写了下去。今天调试出来好像流程都能对上</p><p>第三阶段部分相比之下就简单快乐很之多，下午加晚上除了搜索部分，其他基本功能都完成差不多了。</p><h4 id="day-6-3-17"><a href="#day-6-3-17" class="headerlink" title="day 6__3.17"></a>day 6__3.17</h4><blockquote><ul><li><input checked="" disabled="" type="checkbox"> 完成第三阶段基本要求</li><li><input checked="" disabled="" type="checkbox"> 添加注册的邮箱验证功能</li><li><input checked="" disabled="" type="checkbox"> 改一下第一阶段</li><li><input checked="" disabled="" type="checkbox"> 第四阶段：用户跳转授权时后端获取token、使用token连接Bangumi的api</li></ul></blockquote><p>今天应该是收获最大的一天。无论是实现邮箱验证功能还是实现OAuth2.0的Client，感觉自己越来越理解其中所涉及的知识和原理了。</p><p>以及StackOverFlow太好用了 又成功解决好几个bug</p><h4 id="day-7-3-18"><a href="#day-7-3-18" class="headerlink" title="day 7___3.18"></a>day 7___3.18</h4><blockquote><ul><li><input checked="" disabled="" type="checkbox"> 第四阶段完成绑定账号后的数据导入</li><li><input checked="" disabled="" type="checkbox"> 重新捋一下第二阶段（获取code时的get&amp;post）</li><li><input checked="" disabled="" type="checkbox"> 最终debug</li></ul></blockquote><p>最后一天，好舍不得啊感觉。算是把四个阶段都基本完成啦，虽然很多环节都离完美差得远，但已经很满足了</p><hr><h2 id="OAuth2-0-Server"><a href="#OAuth2-0-Server" class="headerlink" title="OAuth2.0 Server:"></a>OAuth2.0 Server:</h2><ol><li><p>client在<code>/aouth2.0/sign</code>注册应用，自定义密匙，获得client ID</p></li><li><p>进行第三方登录时，用户跳转到授权页<code>/oauth2.0/show?client_id=xxxxxxxx&amp;redirect_url=http://xxxxxx/redirect</code>，并登录：</p><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs perl">&#123; <br><br><span class="hljs-string">&quot;email&quot;</span>:<span class="hljs-string">&quot;2333@moe.com&quot;</span>, <br><br><span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;233333&quot;</span> <br><br>&#125;<br></code></pre></td></tr></table></figure><p>server确认信息后回调redirect_url，并返回code：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123; <br><br>&quot;<span class="hljs-selector-tag">code</span>&quot;:<br><span class="hljs-string">&quot;eyJhbGciOiJIUzUxMiIsImlhdCI6MTY0NzU3OTc2OSwiZXhwIjoxNjQ3NTgwMzY5fQ.Mw.ajuLe4SskMkCVK_aIlUIjetDoUndZ3F92rW_ud6BjRdLSniuSKum2xPrtQvQrCK1V3yVq9gBJSwGKWnYamDqQ&quot;</span> <br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>client获取code后，向<code>/oauth2.0/granttoken</code>发送client_id、client_secrets和code：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><br>    <span class="hljs-attr">&quot;client_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IPfapHgWOn58ycjMCRBD&quot;</span><span class="hljs-punctuation">,</span><br>    <br>    <span class="hljs-attr">&quot;client_secrets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123456&quot;</span><span class="hljs-punctuation">,</span><br>    <br>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eyJhbGciOiJIUzUxMiIsImlhdCI6MTY0NzU4MDg4OCwiZXhwIjoxNjQ3NTgxNDg4fQ.Mw.dUPFfwWfPsyzijw5lGnx6VuaKlYBb21zlSycCkyFRVpjjEAGR2gQejmR7hWi_2JXjYAPmPoyBpkV4D6LuTGarg&quot;</span><br>    <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>server返回用户对应的token。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><br>    <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eyJhbGciOiJIUzUxMiIsImlhdCI6MTY0NzU4MDk0NiwiZXhwIjoxNjQ3NTg0NTQ2fQ.eyJlbWFpbCI6IjIzMzNAbW9lLmNvbSIsInVpZCI6M30.Kl_pri4sOp9ErP2yseuy-h_q4_884Qit6yEI0U4akUoDnBl4e6r3tmHVJj3MR5YQ7O7KmSEZAu_H-6VuD_nj7w&quot;</span><br>    <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>获取用户信息的api：<code>/aouth2.0/getinfo</code></p><p>向<code>/aouth2.0/getinfo</code>发送token</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><br>    <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eyJhbGciOiJIUzUxMiIsImlhdCI6MTY0NzU4MDk0NiwiZXhwIjoxNjQ3NTg0NTQ2fQ.eyJlbWFpbCI6IjIzMzNAbW9lLmNvbSIsInVpZCI6M30.Kl_pri4sOp9ErP2yseuy-h_q4_884Qit6yEI0U4akUoDnBl4e6r3tmHVJj3MR5YQ7O7KmSEZAu_H-6VuD_nj7w&quot;</span><br>    <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>server返回：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br>    <span class="hljs-string">&quot;avator&quot;</span>: <span class="hljs-string">&quot;https://bangumi.tv/user/675222&quot;</span>,<br>    <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;2333@moe.com&quot;</span>,<br>    <span class="hljs-string">&quot;intro&quot;</span>: <span class="hljs-string">&quot;here is moee&quot;</span>,<br>    <span class="hljs-string">&quot;nickname&quot;</span>: <span class="hljs-string">&quot;moee&quot;</span>,<br>    <span class="hljs-string">&quot;uname&quot;</span>: <span class="hljs-string">&quot;2333@moe.com&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="OAuth2-0-Client"><a href="#OAuth2-0-Client" class="headerlink" title="OAuth2.0 Client:"></a>OAuth2.0 Client:</h2><ol><li><p>用户点击”绑定第三方bangumi账号“，跳转到bangumi授权页</p><p><code>https://bgm.tv/oauth/authorize?client_id=bgm22106232fa6225d8a&amp;response_type=code&amp;redirect_uri=http%3A%2F%2F127.0.0.1%3A5000%2Foauth%2Fredirect</code></p><p>进行授权。</p></li><li><p>用户成功授权后Bangumi Server跳转回redirect_uri（<code>http://127.0.0.1:5000/oauth2.0/redirect</code>），并返回code。</p></li><li><p>Client接收code，并向<code>https://bgm.tv/oauth/access_token</code>使用code换取token：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">POST https:<span class="hljs-regexp">//</span>bgm.tv<span class="hljs-regexp">/oauth/</span>access_token<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<br>      <span class="hljs-string">&quot;grant_type&quot;</span>: <span class="hljs-string">&quot;authorization_code&quot;</span>,<br>      <span class="hljs-string">&quot;client_id&quot;</span>: &#x27;bgm<span class="hljs-number">22106232</span>fa<span class="hljs-number">6225</span>d8a&#x27;,<br>      <span class="hljs-string">&quot;client_secret&quot;</span>: &#x27;<span class="hljs-number">7402491845</span>d1b66ce<span class="hljs-number">1360</span>c<span class="hljs-number">3329</span>3b472a&#x27;,<br>      <span class="hljs-string">&quot;code&quot;</span>: code,<br>      <span class="hljs-string">&quot;redirect_uri&quot;</span>: &#x27;http://127.0.0.1:<span class="hljs-number">5000</span>/oauth/redirect&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>接收到Server返回的access_token：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;xxxxxxxx&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">604800</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Bearer&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scope&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-keyword">null</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;xxxxxxxx&quot;</span><br>    <span class="hljs-attr">&quot;user_id&quot;</span> <span class="hljs-punctuation">:</span> xxxxx<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>Client将获取的access_token写入数据库，利用bangumi提供的api导入用户番剧收藏数据。</p><p>(bangumi提供的api似乎有点bug，没法正常导出番剧评论，但番剧名和状态是可以正常导出的)</p></li></ol><h2 id="邮箱验证："><a href="#邮箱验证：" class="headerlink" title="邮箱验证："></a>邮箱验证：</h2><p>利用Flask的<strong>Flask-Mail</strong>扩展向用户发送验证邮件</p><p>token使用itsdangerous的TimedJSONWebSignatureSerializer()生成，有效期为10分钟</p><p>用户点击验证链接，server接收到token进行解析，判断uid与session中的uid是否相符，相符则验证成功</p><h2 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h2><p>MySQL + SQLAlchemy</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--------------------+</span><br><span class="hljs-section">| Tables_in_bangumoe |</span><br><span class="hljs-section">+--------------------+</span><br>| users              |<br>| info               |<br>| oauth              |<br>| anime              |<br><span class="hljs-section">| collection         |</span><br><span class="hljs-section">+--------------------+</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note for Python 02</title>
    <link href="/2022/02/16/PygameNote/"/>
    <url>/2022/02/16/PygameNote/</url>
    
    <content type="html"><![CDATA[<h1 id="Pygame"><a href="#Pygame" class="headerlink" title="Pygame"></a>Pygame</h1><blockquote><p><a href="https://www.pygame.org/docs/">官方文档 </a></p></blockquote><h3 id="1-模块常用内容"><a href="#1-模块常用内容" class="headerlink" title="1.模块常用内容"></a>1.模块常用内容</h3><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><ul><li><strong>init()：</strong> 初始化程序</li><li><strong>quit()：</strong> 卸载所有模块</li></ul><h4 id="子模块-amp-函数："><a href="#子模块-amp-函数：" class="headerlink" title="子模块 &amp; 函数："></a>子模块 &amp; 函数：</h4><ul><li><strong>display模块</strong><ul><li><strong>set_caption()</strong> ：设置窗口标题</li><li><strong>set_mode()</strong> ：创建图形类型Surface对象</li><li><strong>set_icon()</strong> ：设置左上角的游戏图标，图标尺寸大小为 32*32。</li><li><strong>flip()</strong> ：更新屏幕内容</li></ul></li><li><strong>event模块</strong><ul><li><strong>get()</strong> ：获取事件</li></ul></li><li><strong>font模块</strong><ul><li><strong>Font()</strong> ：创建Font对象</li></ul></li><li><strong>time模块</strong><ul><li><strong>pygame.time.get_ticks()</strong> ：以毫秒为单位获取时间</li><li><strong>pygame.time.wait()</strong> ：使程序暂停一段时间</li><li><strong>pygame.time.set_timer()</strong> ：创建一个定时器，即每隔一段时间，去执行一些动作</li><li><strong>pygame.time.Clock()</strong> ：创建一个时钟对象来帮我们确定游戏要以多大的帧数运行</li></ul></li><li><strong>image模块</strong><ul><li><strong>load()</strong> ：将图像返回为一个Surface对象</li></ul></li></ul><h4 id="类-amp-方法："><a href="#类-amp-方法：" class="headerlink" title="类 &amp; 方法："></a>类 &amp; 方法：</h4><ul><li><p><strong>Surface类</strong></p><ul><li><strong>Surface(size&#x3D;(width,height),flags,depth)</strong> ：创建一个surface类</li><li><strong>fill()</strong> ：填充颜色</li><li><strong>set_alpha()</strong> ：设置整个图像的透明度</li><li><strong>blit()</strong> ：拼接Surface对象，第一个参数为一个Surface对象表内容，第二个参数为一个Rect对象表位置</li><li><strong>scroll()</strong> ：复制并移动 Surface 对象</li><li><strong>subsurface()</strong> ：根据父对象创建一个新的子 Surface 对象</li><li><strong>get_rect()</strong> ：获得自身表rect区域坐标的Rect对象</li></ul></li><li><p><strong>Font类</strong></p><ul><li><strong>render()</strong> ：创建文本类型Surface对象</li></ul></li><li><p><strong>Rect类</strong></p><ul><li><strong>Rect(left,top,width,height)</strong> ：创建一个Rect类，表示窗口上的一块矩形区域</li><li><strong>center</strong>：表显示中心坐标</li></ul></li><li><p><strong>Event类</strong></p><ul><li><strong>type</strong></li></ul></li></ul><h3 id="2-初始化程序"><a href="#2-初始化程序" class="headerlink" title="2. 初始化程序"></a>2. 初始化程序</h3><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs python">pygame.init()<br></code></pre></td></tr></table></figure><p>它的作用是自动检测 Pygame 软件包是否正常可用，并检查电脑的硬件调用接口、基础功能是否存在问题，比如音频、光驱、声卡驱动等设备。同时，它会完成 <strong>Pygame 中所有模块的初始化操作</strong>，比如 display（显示模块）、font（字体模块）、mixer（声音控制模块）、cursors（光标控制模块）等。</p><h3 id="3-创建Surface对象"><a href="#3-创建Surface对象" class="headerlink" title="3. 创建Surface对象"></a>3. 创建Surface对象</h3><p><strong>创建一个 surface 对象：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">screen = pygame.display.set_mode((<span class="hljs-number">800</span>,<span class="hljs-number">600</span>))<br></code></pre></td></tr></table></figure><p><strong>设置背景颜色</strong>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">screen</span>.fill((<span class="hljs-number">138</span>,<span class="hljs-number">151</span>,<span class="hljs-number">146</span>))<br></code></pre></td></tr></table></figure><p>screen 是一个 Surface 对象，它是游戏的主窗口，任何其他的 Surface 对象都需要附着于此。</p><p>创建包含文本的 Surface 对象，然后将它绘制在主屏幕上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建一个包含文字的Surface对象</span><br>text = f.render(<span class="hljs-string">&quot;Hello, world!&quot;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>))<br><span class="hljs-comment">#通过blit方法将其绘制在主屏幕上，textRect表示位置坐标</span><br>screen.blit(text,textRect)<br></code></pre></td></tr></table></figure><p><strong>创建一个图像的Surface对象</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">surface_image =pygame.image.load(<span class="hljs-string">&quot;图片路径&quot;</span>) <br></code></pre></td></tr></table></figure><h3 id="4-事件监听"><a href="#4-事件监听" class="headerlink" title="4. 事件监听"></a>4. 事件监听</h3><p>Pygame 提供了一个 event 模块，这个模块中包含了所有常用到游戏事件。如退出游戏：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 循环获取事件，监听事件状态，使用get()获取事件</span><br><span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br><span class="hljs-comment"># 判断事件类型，用户是否点了&quot;X&quot;关闭按钮(pygame.QUIT)</span><br><span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:   <br>pygame.quit()<br></code></pre></td></tr></table></figure><h3 id="5-游戏循环"><a href="#5-游戏循环" class="headerlink" title="5. 游戏循环"></a>5. 游戏循环</h3><p>如果想要达到“循环监听”目的，需要设置一个游戏循环（Game Loop）也称为游戏的主循环。一个最基本的只包含退出操作的主循环如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <br>    <span class="hljs-comment"># 循环获取事件，监听事件    </span><br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():        <br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:            <br>        <span class="hljs-comment"># 当用户关闭游戏窗口时执行以下操作            </span><br>            pygame.quit()                   <br>            sys.exit()    <br>    <span class="hljs-comment">#更新并绘制屏幕内容    </span><br>    pygame.display.flip() <br></code></pre></td></tr></table></figure><p>游戏主循环主要承担以下任务：</p><ul><li>处理游戏事件</li><li>更新游戏状态</li><li>把更新后的游戏状态绘制到屏幕上</li></ul><p>游戏画面和游戏操作状态会因为动画效果和玩家的操作而改变，因此需要以循环的方式实时地更新主屏幕（screen）的显示内容。把下列代码放入游戏主循环中即可实现实时更新和绘制屏幕内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#刷新界面显示</span><br>pygame.display.flip() <br></code></pre></td></tr></table></figure><p>除了上述方法外，Pygame 还提供了另一个方法：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">pygame.<span class="hljs-keyword">display</span>.up<span class="hljs-meta">date</span>() <br></code></pre></td></tr></table></figure><p>这两个方法的主要区别是：后者可以根据选定的区域来更新部分内容，而前者则是更新整个待显示的内容。如果后者没有提供区域位置参数时，其作用和 display.flip() 相同。</p><h2 id="display模块"><a href="#display模块" class="headerlink" title="display模块"></a>display模块</h2><h4 id="创建游戏主窗口："><a href="#创建游戏主窗口：" class="headerlink" title="创建游戏主窗口："></a>创建游戏主窗口：</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">screen = pygame.display.<span class="hljs-built_in">set_mode</span>(size=(),flags=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>Display模块中的<code>set_mode()</code>函数负责创建Surface对象，它返回一个Surface对象，同时接收两个参数用于设置窗口大小和样式：</p><ul><li><strong>size：</strong>元组参数，用来设置主窗口的大小</li><li><strong>flags：</strong>功能标志位，表示创建的主窗口样式，比如创建全屏窗口、无边框窗口等</li><li>在主窗口中，我们还可以添加各种小的 Surface 对象，这些对象以矩形的形式存在于主窗口中，它们共同组成了一个游戏程序。通过blit方法将一个 Surface 对象粘贴至主窗口上：</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">screen.blit(source, dest, <span class="hljs-built_in">area</span>=<span class="hljs-built_in">None</span>, special_flags = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="Surface类：创建图像"><a href="#Surface类：创建图像" class="headerlink" title="Surface类：创建图像"></a>Surface类：创建图像</h2><p>Pygame 针对文本、图像、颜色提供了不同模块来生成它们各自的 Surface 对象。</p><h4 id="Surface-函数"><a href="#Surface-函数" class="headerlink" title="Surface()函数"></a>Surface()函数</h4><p>是Pygame 中专门用来新建图像的，可以创建一个 Surface 对象，语法格式如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Surface=pygame.<span class="hljs-constructor">Surface(<span class="hljs-params">size</span>=(<span class="hljs-params">width</span>,<span class="hljs-params">height</span>)</span>,flags,depth)<br></code></pre></td></tr></table></figure><p>参数函数如下：</p><ul><li>size：表示 Surface 对象的矩形区域大小；</li><li>flags：功能标志位，有两个可选参数值 HWSURFACE 和 SPCALPHA。HWSURFACE 代表将创建的 Surface 对象存放于显存中， SPCALPHA表示让图像的每一个像素都包含一个 alpha 通道</li><li>depth：指定像素的颜色深度，默认为自适应模式，由 Pygame 自动调节。</li></ul><h2 id="image模块"><a href="#image模块" class="headerlink" title="image模块"></a>image模块</h2><p>除了使用 Surface 模块新建图像外，另外一种从外部加载图像的方法：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">pygame.<span class="hljs-built_in">image</span>.<span class="hljs-built_in">load</span>(<span class="hljs-string">&quot;图片路径&quot;</span>).<span class="hljs-built_in">convert</span>()  <br></code></pre></td></tr></table></figure><p>该方法返回一个 Surface 对象。convert(）用于转换被加载图片的像素格式，从而提升 Pygame 对图片的处理速度，该操作能够保证图像的像素格式与图片的显示格式是相同的。</p><h2 id="time模块：时间控制"><a href="#time模块：时间控制" class="headerlink" title="time模块：时间控制"></a>time模块：时间控制</h2><p>time 模块主要用于管理时间和帧数率（即 FPS）。</p><p><strong>Point：</strong>Pygame 中时间以毫秒为单位（1秒&#x3D;1000毫秒）。</p><h3 id="1-游戏暂停"><a href="#1-游戏暂停" class="headerlink" title="1) 游戏暂停"></a>1) 游戏暂停</h3><p>常用方法如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.time.get_ticks()</td><td>以毫秒为单位获取时间</td></tr><tr><td>pygame.time.wait()</td><td>使程序暂停一段时间</td></tr><tr><td>pygame.time.set_timer()</td><td>创建一个定时器，即每隔一段时间，去执行一些动作</td></tr><tr><td>pygame.time.Clock()</td><td>创建一个时钟对象来帮我们确定游戏要以多大的帧数运行</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br>pygame.init()<br>screen = pygame.display.set_mode((<span class="hljs-number">500</span>,<span class="hljs-number">500</span>))<br><span class="hljs-comment"># 获取以毫秒为单位的时间</span><br>t = pygame.time.get_ticks() <span class="hljs-comment">#该时间指的从pygame初始化后开始计算，到调用该函数为止</span><br>t1 =pygame.time.wait(<span class="hljs-number">3000</span>) <span class="hljs-comment">#暂停游戏3000毫秒</span><br><span class="hljs-built_in">print</span>(t1)<br><span class="hljs-comment">#暂停t1时间后，加载图片</span><br>image_surface = pygame.image.load(<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/c-net.png&quot;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            exit()<br>    screen.blit(image_surface,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>    pygame.display.update()<br></code></pre></td></tr></table></figure><h3 id="2-设置游戏FPS"><a href="#2-设置游戏FPS" class="headerlink" title="2) 设置游戏FPS"></a>2) 设置游戏FPS</h3><p>设置游戏的帧数率（FPS）可通过 Clock() 方法来实现：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.time.Clock.tick()</td><td>更新clock对象</td></tr><tr><td>pygame.time.Clock.get_time()</td><td>获取上一个tick中的时间</td></tr><tr><td>pygame.time.Clock.get_fps()</td><td>计算clock对象的帧率</td></tr></tbody></table><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建时钟对象（控制游戏的FPS）</span><br>clock = pygame.time.Clock()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#通过时钟对象，指定循环频率，每秒循环60次</span><br>    clock.tick(<span class="hljs-number">60</span>)<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            exit()<br>    screen.blit(image_surface,(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>    pygame.display.update()<br></code></pre></td></tr></table></figure><p>注意：FPS（游戏帧率）影响效果只有在动态图时才能显现出来，不过无论静态图还是动态图，它们的使用规则都是一样的。</p><h2 id="Rect类：区域位置"><a href="#Rect类：区域位置" class="headerlink" title="Rect类：区域位置"></a>Rect类：区域位置</h2><p>Rect（rectangle）指的是矩形，使用 Rect() 方法来创建一个指定位置，大小的矩形区域如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">rect =pygame.<span class="hljs-constructor">Rect(<span class="hljs-params">left</span>,<span class="hljs-params">top</span>,<span class="hljs-params">width</span>,<span class="hljs-params">height</span>)</span> <br></code></pre></td></tr></table></figure><p>Rect 表示的区域必须位于一个 Surface 对象之上，比如游戏的主窗口。</p><p><strong>Point</strong>：在 Pygame 中以游戏主窗口的左上角为坐标原点。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">image_surface = pygame.image.load(<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/c-net.png&quot;</span>)<br><br>rect1 = pygame.Rect(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>)<br><span class="hljs-comment"># 在原图的基础上创建一个新的子图（surface对象）</span><br>image_child= image_surface.subsurface(rect1)<br><br>rect2 = image_child.get_rect()<br><span class="hljs-comment">#输出的矩形大小为 100*100</span><br><span class="hljs-built_in">print</span>(rect2)<br><br>screen.blit(image_child,rect1)<br></code></pre></td></tr></table></figure><p>可通过属性对来设置更改矩形区域的大小：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">rect1.left</span> = <span class="hljs-number">30</span> <br><span class="hljs-attr">rect1.center</span> = (<span class="hljs-number">70</span>,<span class="hljs-number">70</span>)<br></code></pre></td></tr></table></figure><p>除了通过 Rect 对象来构造一个矩形区域之外，还可以使用<code>rect</code>属性来构建一个矩形区域。在 Pygame 中有许多函数都提供了<code>rect</code>属性，比如有下列函数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">surface</span>.fill((<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>),rect=(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">50</span>))<br></code></pre></td></tr></table></figure><p>上述代码会在 surface 对象的区域内选定一个 rect 区域，并将该区域填充为蓝色（RGB(0,0,255)）。</p><h2 id="event模块"><a href="#event模块" class="headerlink" title="event模块"></a>event模块</h2><p>事件（Event）是构建整个游戏程序的核心，比如鼠标点击、键盘敲击、游戏窗口移动、调整窗口大小、触发特定的情节、退出游戏等。<strong>Pygame 定义了一个专门用来处理事件的结构，即事件队列</strong>。该结构遵循队列“先进先出”的基本原则，通过事件队列，我们可以有序的、逐一的处理用户的操作。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#等待事件发生</span><br>    event = pygame.event.wait()<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>        exit()<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEBUTTONDOWN:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标按下&#x27;</span>,event.pos)<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEBUTTONUP:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标弹起&#x27;</span>)<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEMOTION:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标移动&#x27;</span>)<br>        <span class="hljs-comment"># 键盘事件</span><br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> ==pygame.KEYDOWN:<br>        <span class="hljs-comment"># 打印按键的英文字符</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘按下&#x27;</span>,<span class="hljs-built_in">chr</span>(event.key))<br>    <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.KEYUP:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘弹起&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="处理键盘事件"><a href="#处理键盘事件" class="headerlink" title="处理键盘事件"></a>处理键盘事件</h3><p>键盘事件提供了一个 key 属性，通过该属性可以获取键盘的按键。Pygame 将键盘上的字母键、数字键、组合键等按键以常量的方式进行了定义。示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">while</span> True:<br>    site = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.type == pygame.QUIT:<br>            sys.<span class="hljs-keyword">exit</span>()<br>        <span class="hljs-comment"># 图像移动 KEYDOWN 键盘按下事件</span><br>        <span class="hljs-comment"># 通过 key 属性对应按键</span><br>        <span class="hljs-keyword">if</span> event.type == pygame.KEYDOWN:<br>            <span class="hljs-keyword">if</span> event.key == pygame.K_UP:<br>                site[<span class="hljs-number">1</span>] -= <span class="hljs-number">8</span><br>            <span class="hljs-keyword">if</span> event.key == pygame.K_DOWN:<br>                site[<span class="hljs-number">1</span>] += <span class="hljs-number">8</span><br>            <span class="hljs-keyword">if</span> event.key == pygame.K_LEFT:<br>                site[<span class="hljs-number">0</span>] -= <span class="hljs-number">8</span><br>            <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>                site[<span class="hljs-number">0</span>] += <span class="hljs-number">8</span><br>    <span class="hljs-comment"># 移动图像</span><br>    position = position.move(site)<br>    <span class="hljs-comment"># 填充背景</span><br>    screen.fill(bg)<br>    <span class="hljs-comment"># 放置图片</span><br>    screen.blit(img, position)<br>    <span class="hljs-comment"># 更新显示界面</span><br>    pygame.display.flip()<br></code></pre></td></tr></table></figure><h3 id="处理鼠标事件"><a href="#处理鼠标事件" class="headerlink" title="处理鼠标事件"></a>处理鼠标事件</h3><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">while</span> True:<br>    <span class="hljs-comment">#等待事件发生</span><br>    event = pygame.event.wait()<br>    <span class="hljs-keyword">if</span> event.type == pygame.QUIT:<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-string">&quot;成功退出&quot;</span>)<br>    <span class="hljs-keyword">if</span> event.type == pygame.MOUSEBUTTONDOWN:<br>        <span class="hljs-comment"># pos 获取鼠标当前位置</span><br>        print(<span class="hljs-string">&#x27;鼠标按下&#x27;</span>,event.pos)<br>        mx,my = event.pos<br>        <span class="hljs-comment"># 调用 pygame.draw 模块画圆</span><br>        pygame.draw.circle(screen,(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),(mx,my),<span class="hljs-number">50</span>)<br>        <span class="hljs-comment"># 处理完，更新显示</span><br>        pygame.display.update()<br>    <span class="hljs-keyword">if</span> event.type == pygame.MOUSEBUTTONUP:<br>        print(<span class="hljs-string">&#x27;鼠标弹起&#x27;</span>)<br>        pass<br>    <span class="hljs-keyword">if</span> event.type == pygame.MOUSEMOTION:<br>        print(<span class="hljs-string">&#x27;鼠标移动&#x27;</span>)<br>        mx, my = event.pos<br>        <span class="hljs-comment"># 随机生成 RGB 颜色值</span><br>        r = randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>        g = randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>        b = randint(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)<br>        pygame.draw.circle(screen, (r,g,b,),(mx, my), <span class="hljs-number">50</span>)<br>        <span class="hljs-comment"># 处理完，更新显示</span><br>        pygame.display.update()<br></code></pre></td></tr></table></figure><h2 id="font模块：文本和字体"><a href="#font模块：文本和字体" class="headerlink" title="font模块：文本和字体"></a>font模块：文本和字体</h2><p><code>pygame.font</code>模块常用方法如下：</p><p>Font 模块提供了两种创建Font类对象的方法，分别是：</p><ul><li>SysFont（从系统中加载字体文件创建字体对象）</li><li>Font（通过文件路径创建字体对象）</li></ul><h4 id="1-font-SysFont"><a href="#1-font-SysFont" class="headerlink" title="1) font.SysFont()"></a>1) font.SysFont()</h4><p>直接从系统中加载字体使用如下方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pygame.font.SysFont(name, size, <span class="hljs-attribute">bold</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">italic</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><ul><li><p>name：列表参数值，表示要从系统中加载的字体名称，它会按照列表中的元素顺序依次搜索，如果系统中没有列表中的字体，将使用 Pygame 默认的字体。</p></li><li><p>size：表示字体的大小；</p></li><li><p>bold：字体是否加粗；</p></li><li><p>italic：字体是否为斜体。</p></li></ul><h4 id="2-font-Font"><a href="#2-font-Font" class="headerlink" title="2) font.Font()"></a>2) font.Font()</h4><p>Font()可从外部加载字体文件来绘制文本：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">my_font = pygame.font.<span class="hljs-constructor">Font(<span class="hljs-params">filename</span>, <span class="hljs-params">size</span>)</span> <br></code></pre></td></tr></table></figure><ul><li>filename：字符串格式，表示字体文件的所在路径；</li><li>size：设置字体的大小。</li></ul><h2 id="sprite模块：精灵和碰撞检测"><a href="#sprite模块：精灵和碰撞检测" class="headerlink" title="sprite模块：精灵和碰撞检测"></a>sprite模块：精灵和碰撞检测</h2><p>在一个游戏程序中，精灵（ Sprite）本质指的是一张张小尺寸的图片，比如游戏中的各种道具、人物、场景装饰等，它们都可以看做成一张张小的“精灵”图。除此之外，人物的移动也可以看做是一系列小精灵图构成的序列（按帧组成的序列）。</p><p>如果将逐帧分解后的动作，按照一定的频率播放，那么就形成了动画精灵。</p><p>精灵有个特点就是允许精灵之间进行交互，也称之为碰撞，而碰撞检测，指的就是检测两个精灵之间是否发生了碰撞。比如在贪吃蛇游戏中蛇的头部是否与食物发生了碰撞，或者飞机大战游戏中子弹是否击中了外星人等等。当检测到碰撞发生后，接下来会触发某些事件，比如子弹击中外星人，外星人就会消失，玩家的得分也会随之增加，并且在游戏屏幕上又会出现一个外星人。</p><p>Pygame 专门提供了一个处理精灵的模块，也就是 sprite模块。<strong>通常使用该模块的基类 Sprite 来创建一个子类，从而达到处理精灵的目的</strong> ，该子类提供了操作精灵的常用属性和方法。</p><p>当游戏中有大量的精灵时，操作它们将变得复杂，此时通过构建精灵容器（group 类）也就是精灵组来统一管理这些精灵。构建方法如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 创建精灵组</span><br><span class="hljs-keyword">group</span> <span class="hljs-title">= pygame</span>.sprite.Group()<br><span class="hljs-comment"># 向组内添加一个精灵</span><br>group.add(sprite_one)<br></code></pre></td></tr></table></figure><p>于此同时<code>pygame.sprite</code>模块也提供了多种检测精灵是否碰撞的方法。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span>(pygame.sprite.Sprite):<br>    <span class="hljs-comment">#定义构造函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,filename,location</span>):<br>        <span class="hljs-comment"># 调父类来初始化子类</span><br>        pygame.sprite.Sprite.__init__(self)<br>        <span class="hljs-comment"># 加载图片</span><br>        self.image = pygame.image.load(filename)<br>        <span class="hljs-comment"># 获取图片rect区域</span><br>        self.rect = self.image.get_rect()<br>        <span class="hljs-comment"># 设置位置</span><br>        self.rect.topleft=location<br><span class="hljs-comment"># 初始化pygame</span><br>pygame.init()<br>screen = pygame.display.set_mode((<span class="hljs-number">500</span>,<span class="hljs-number">400</span>))<br><br><span class="hljs-comment"># 填充为白色屏幕</span><br>screen.fill((<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>))<br>filename =<span class="hljs-string">&quot;C:/Users/Administrator/Desktop/snake.png&quot;</span><br>location =(<span class="hljs-number">100</span>,<span class="hljs-number">150</span>)<br>snake1 = Snake(filename,location)<br><span class="hljs-comment"># 碰撞检测,必须有两个精灵，因此再创建一个精灵，并使用location来控制第二个精灵的位置</span><br>location_2 = (<span class="hljs-number">100</span>,<span class="hljs-number">80</span>)<br>snake2 = Snake(<span class="hljs-string">&#x27;C:/Users/Administrator/Desktop/logo.png&#x27;</span>,location_2)<br><span class="hljs-comment"># 调用 collide_rect()进行矩形区域检测，返回一个布尔值，碰撞返回True，否则返回False</span><br>crash_result = pygame.sprite.collide_rect(snake1,snake2)<br><span class="hljs-keyword">if</span> crash_result:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;精灵碰撞了!&quot;</span>)<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;精灵没碰撞&#x27;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            pygame.quit()<br>            exit()<br>    <span class="hljs-comment"># 绘制精灵到屏幕上</span><br>    screen.blit(snake1.image,snake1.rect)<br>    screen.blit(snake2.image,snake2.rect)<br>    <span class="hljs-comment"># 刷新显示屏幕</span><br>    pygame.display.update()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note for Python 01</title>
    <link href="/2022/02/10/PythonNote/"/>
    <url>/2022/02/10/PythonNote/</url>
    
    <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h3 id="动态语言-amp-静态语言："><a href="#动态语言-amp-静态语言：" class="headerlink" title="动态语言 &amp; 静态语言："></a>动态语言 &amp; 静态语言：</h3><ul><li><p><strong>动态语言：</strong>变量本身类型不固定。使用变量无需声明，但使用前必须赋值，赋值后变量才被创建。</p><p><strong>e.g. Python、Ruby、JavaScript</strong></p></li><li><p><strong>静态语言：</strong>变量类型固定。在定义变量时必须指定变量类型，赋值时变量与对象的类型必须相匹配or进行转化。</p><p><strong>e.g. Java、C、C++</strong></p></li></ul><blockquote><p>动态语言和静态语言很大的不同在于：函数和类的定义不是编译时定义的，而是运行时动态创建的。</p></blockquote><h3 id="引用赋值："><a href="#引用赋值：" class="headerlink" title="引用赋值："></a>引用赋值：</h3><p>像Python、JS这类动态语言，基本上都是使用引用赋值。在引用赋值中，变量名和真实值分开保存。变量名保存的是真实值的一个指针，对变量赋值时，也是将这个指针赋给新变量，原来的“引用”则断开了。</p><h3 id="Python中的不可变类型-amp-可变类型："><a href="#Python中的不可变类型-amp-可变类型：" class="headerlink" title="Python中的不可变类型 &amp; 可变类型："></a>Python中的不可变类型 &amp; 可变类型：</h3><ul><li><p><strong>不可变类型： Number、String、Tuple</strong></p><p>当变量为不可变类型时，无法在内存中直接修改这个变量（如：100、’hello‘）。如果尝试对不可变类型进行修改，就会断开原始的引用，重新指向新的对象。</p></li><li><p><strong>可变类型：List、Dictionary、Set</strong></p><p>可以在内存中进行修改，修改可变类型的值不会断开原始引用。</p></li></ul><h3 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h3><p>主动发起TCP链接，接收服务器返回数据，实现一次完整的网络通信。</p><p>以获取新浪首页HTML文件为例：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#tcp基本连接新浪首页获取并打印http头</span><br><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> ssl<br><br>s = ssl.wrap_socket(socket.socket())<br><br><span class="hljs-comment">#建立连接</span><br>s.connect((<span class="hljs-string">&#x27;www.sina.com.cn&#x27;</span>, <span class="hljs-number">443</span>))<br><br>s.send(<span class="hljs-string">b&quot;GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n&quot;</span>)<br><br><span class="hljs-comment">#接受数据</span><br>buf = []<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    d = s.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-keyword">if</span> d:<br>        buf.append(d)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br>data = <span class="hljs-string">b&quot;&quot;</span>.join(buf)<br><br><span class="hljs-comment">#关闭tcp连接</span><br>s.close()<br><br>data = data.split(<span class="hljs-string">b&#x27;\r\n\r\n&#x27;</span>,<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#打印请求头把流数据进行解码</span><br><span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span>].decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br><span class="hljs-comment">#写进文件html，存入本地文件夹</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:/SE/CODE/Python/sina.html&quot;</span>,<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(data[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iFleaBooks</title>
    <link href="/2022/02/06/iFleaBooks/"/>
    <url>/2022/02/06/iFleaBooks/</url>
    
    <content type="html"><![CDATA[<h1 id="iFleaBooks"><a href="#iFleaBooks" class="headerlink" title="iFleaBooks"></a>iFleaBooks</h1><p>Linux环境下的二手书交易系统</p><p>是一个C++练手项目，实现了较完整的交易系统前后台功能，包括用户注册、登录、浏览商品、发布商品、修改信息，管理员进行后台数据管理，本地数据载入与更新等，并基于Linux命令行进行交互。</p><p><strong>GitHub链接：</strong><a href="https://github.com/yinn-x/iFleaBooks">https://github.com/yinn-x/iFleaBooks</a></p><hr><h3 id="开发环境："><a href="#开发环境：" class="headerlink" title="开发环境："></a><strong>开发环境：</strong></h3><p>Ubuntu &amp; VS Code</p><h3 id="实现功能："><a href="#实现功能：" class="headerlink" title="实现功能："></a><strong>实现功能：</strong></h3><p><strong>User：</strong></p><ul><li>注册 &amp; 登录 &amp; 注销；</li><li>浏览书库 &#x2F; 搜索书籍 &amp; 查看书的详细信息；</li><li>购买二手书 &amp; 查看已购订单；</li><li>发布二手书 &amp; 修改详细信息；</li><li>下架自己的发布 &amp; 查看卖出订单；</li><li>个人信息管理 &amp; 钱包充值。</li></ul><p><strong>Admin：</strong></p><ul><li>查看 &#x2F; 检索所有书籍 &amp; 下架书籍；</li><li>查看和管理所有订单；</li><li>查看和管理所有用户信息。</li></ul><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a><strong>效果</strong>：</h3><p>登录界面 &amp; 注册 ：</p>  <img src="/img/iFleaBooks/11.png" style="zoom:50%;" /><p>​          </p><p>浏览界面：</p> <img src="/img/iFleaBooks/22.png" style="zoom:50%;" /><p>​           </p><p>买书界面：</p>  <img src="/img/iFleaBooks/2.png" style="zoom:50%;" /><p>​       </p><p>钱包充值：</p>  <img src="/img/iFleaBooks/3.png" style="zoom:50%;" /><p>​     </p><p>管理员界面：</p><img src="/img/iFleaBooks/4.png" style="zoom:50%;" /><p>​    </p><p>还有一堆界面懒得截了（雾</p>]]></content>
    
    
    <categories>
      
      <category>Projects</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Note of C++ Primer</title>
    <link href="/2022/02/02/Note%20of%20C++%20Primer/"/>
    <url>/2022/02/02/Note%20of%20C++%20Primer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-从-C-到-C"><a href="#1-从-C-到-C" class="headerlink" title="1. 从 C 到 C++"></a>1. 从 C 到 C++</h1><p>一些 C++ 的新特性：</p><p><strong>多态：</strong></p><ul><li><p>静态多态：</p><p>（1）重载（函数重载 &amp; 运算符重载） </p><p>（2）泛型（函数模板 &amp; 类模板）</p></li><li><p>动态多态：虚函数</p></li></ul><p><strong>类：</strong></p><ul><li><p>继承（基类 &amp; 子类）</p></li><li><p>封装 （类访问修饰符 &amp; 友元）</p></li><li><p>其他细节：（1）类的默认函数</p><p>​                   （2）运算符重载</p><p>​                   （3）this 指针</p></li></ul><p><strong>其他：</strong></p><ul><li><p>引用变量</p></li><li><p>范围 for 语句</p></li><li><p>迭代器</p></li><li><p>内联函数</p></li><li><p>new &amp; delete</p></li><li><p>流式文件读写</p></li><li><p>函数的默认参数</p></li></ul><h2 id="2-多态"><a href="#2-多态" class="headerlink" title="2. 多态"></a>2. 多态</h2><h4 id="（1）泛型编程"><a href="#（1）泛型编程" class="headerlink" title="（1）泛型编程"></a>（1）泛型编程</h4><p>泛型编程在 C++ 中主要通过模板函数和模板类实现。</p><p>函数模板的性质：</p><ol><li>函数模板不是真正的函数，只是编译时生成具体函数的一个”模子”。</li><li>函数模板不是编译一份满足多重需要，而是为每一种替换它的函数编译生成一份新函数。</li></ol><p>函数模板的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span>&#123;<br>T t = a;<br>a = b, b = t;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>template用于声明开始泛型编程，typyname用于声明泛指类型。</p></li><li><p>自动类型推导调用:</p><p><code> Swap(a, b);</code> </p><p>该调用属于隐式实例化。</p></li><li><p>具体类型显式调用：</p><p><code>Swap&lt;int&gt;(a, b);</code></p><p>该调用属于显式实例化。</p></li></ul><p>显式具体化：</p><p>一种模板定义，实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>&amp;, <span class="hljs-type">int</span>&amp;)&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>或：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;, <span class="hljs-type">int</span>&amp;)</span></span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>意为“当实参为两个int类型时，不要使用Swap()模板来生成函数定义，而应使用专门为int类型显式地定义地具体函数”。</p><h4 id="（2）动态多态"><a href="#（2）动态多态" class="headerlink" title="（2）动态多态"></a>（2）动态多态</h4><p>动态多态主要通过继承重写基类的虚函数实现，在程序运行时根据基类的指针（或引用）指向的对象来确定自己具体调用哪一个类的虚函数。</p><h2 id="3-类的4个默认函数"><a href="#3-类的4个默认函数" class="headerlink" title="3. 类的4个默认函数"></a>3. 类的4个默认函数</h2><p>类的4个默认函数分别为构造函数、析构函数、拷贝函数和赋值函数。通常来讲，1个类包含多个构造函数（由1个或多个普通构造函数与1个拷贝构造函数组成）、1个赋值函数和1个析构函数。若不编写上述函数，C++编译器会自动为类产生4个缺省的函数。然而，使用默认的构造函数与析构函数，相当于放弃了自主“初始化”与“清除”机会。同时，默认的拷贝构造函数、赋值函数采用“位拷贝”而非“值拷贝”，类中含指针变量时将出错。</p><h4 id="（1）构造函数"><a href="#（1）构造函数" class="headerlink" title="（1）构造函数"></a>（1）构造函数</h4><p>构造函数是与类同名、无返回值的特殊成员函数，提供对成员变量初始化的方法。程序创建时将自动调用构造函数。</p><ul><li><p><strong>默认的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>() &#123;<br><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>默认构造函数无参，仅负责创建对象而不进行赋值操作。</p></li><li><p><strong>无参带赋值操作的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>() &#123;<br>name = <span class="hljs-string">&#x27;xiaoming&#x27;</span>;<br>        garde = <span class="hljs-number">90</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该函数将覆盖默认构造函数，它不仅创建对象还负责成员初始化。</p></li><li><p><strong>带参的带赋值操作的构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> g) &#123;<br>name = n;<br>        garde = g;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该构造函数也将覆盖默认的构造函数。</p><p><strong>注意：</strong>一旦类中只包含带参的构造函数而不包含不带参的构造函数时，将无法创建不带参数的对象，程序将报错。</p><p><strong>解决办法：</strong>手动写一个默认构造函数，或给带参函数赋默认参数。</p></li></ul><p><strong>也可通过初始化表进行初始化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>string name;<br><span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> g): <span class="hljs-built_in">name</span>(x), <span class="hljs-built_in">grade</span>(g) &#123;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="（2）拷贝构造函数-amp-赋值函数"><a href="#（2）拷贝构造函数-amp-赋值函数" class="headerlink" title="（2）拷贝构造函数 &amp; 赋值函数"></a>（2）拷贝构造函数 &amp; 赋值函数</h4><p>默认的拷贝构造函数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">Student(<span class="hljs-params">const</span> Student&amp; <span class="hljs-params">stu</span>)</span><br></code></pre></td></tr></table></figure><p>默认的赋值函数：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Student<span class="hljs-meta">&amp; operater=(const Student&amp; stu)</span><br></code></pre></td></tr></table></figure><p>拷贝构造函数是在创建对象时调用，而赋值函数只能被已存在的对象调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;world&quot;</span>)</span></span>;<br>string c = a; <span class="hljs-comment">//调用了拷贝构造函数，也可写成stirng c(a);</span><br>c = b; <span class="hljs-comment">//调用了赋值函数 </span><br></code></pre></td></tr></table></figure><h4 id="（3）析构函数"><a href="#（3）析构函数" class="headerlink" title="（3）析构函数"></a>（3）析构函数</h4><p>也是无参无返回类型的特殊成员函数，但它不能随意调用，没有重载，只有在类对象的生命期结束时，由系统自动调用，用来在系统释放对象前做一些清理工作。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Note</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About</title>
    <link href="/2022/02/01/About/"/>
    <url>/2022/02/01/About/</url>
    
    <content type="html"><![CDATA[<h1 id="About"><a href="#About" class="headerlink" title="About"></a>About</h1><p>这里是YiNN的个人博客！</p><p>本人目前HUST SE大一在读 在写程序这块还是个萌新</p><p>爱好是画点小画，虽然好像很久没画了</p><p>这是我的<a href="https://heeeeeeeeeha.lofter.com/">lofter账号</a></p><p>然后平时大概是比较喜欢看电影刷剧啥的</p><p>这是我的<a href="https://www.douban.com/people/185275812/">豆瓣</a></p><p>(没写完待续)</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/2022/01/28/MyFirstBlog/"/>
    <url>/2022/01/28/MyFirstBlog/</url>
    
    <content type="html"><![CDATA[<p>深夜被一些诡异的报错反复折磨，气到重装Ubuntu。漫长的安装等待中想到，要不边等边把个人博客给建了吧，于是一通操作两天后有了现在的这篇blog。</p><p>鉴于本人的菜鸡水平应该也没办法分享出什么技术，这个博客大概就是给自己的各种笔记啥的找个归属地。</p><p>所以本人的寒假又多了点乐子：把博客建得像模像样一点（误</p>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
